Хакинг искусство эксплоита 2-е 

0x220

- Язык ассемблера # Intel X86, Sparc, ARM

- Языки высокого уровня # С, C++, FORTRAN

- Псевдокод # естественный язык, похож на язык высокого уровня 


0x231

- if-then-else # управляющие операторы
  
  	if (условие) then	{набор инструкций}
	
	else 				{набор инструкций}


0x232

- while/until # циклы 

	while пока (истина) {набор инструкций}

	until пока не (!истина) {набор инструкций}


0x240

- for # цикл со счетчиком

	for (i = 0; i < 5; i++) {набор инструкций}

0x241

- Переменные
	
	int a = 13, b;
	float k;
	char z = 'A';

	k = 3.14;
	z = 'w';
	b = a + 5;


0x242

- b = a + 7 # арифмитические операторы

	 b = a + 5 # Сложение 
	 b = a - 5 # Вычитание
	 b = a * 5 # Умножение
	 b = a / 5 # Деление
	 b = a % 5 # Деление по модулю
	 

- Сокращенная запись:

	i = i + 1 | i++ or ++i # прибавить 1 к переменной

	i = i - 1 | i-- or --i # вычесть 1 к переменной

	-----
	a = 5;
	b = a++ * 6 # a = 6, b = 30 т.к постфиксный инкремент
	b = ++a * 6 # a = 6, b = 36 т.к префиксный инкремент

	-----
	i = i + 12 | i += 12 # Прибавить к переменной значение
	i = i - 12 | i -= 12 # Вычесть из переменной значение
	i = i * 12 | i *= 12 # Умножить переменную на значение
	i = i / 12 | i /= 12 # Разделить переменную на значение 
	

- Логические операторы (Операторы сравнения)

	< | (a < b) # Меньше
	> | (a > b) # больше
	
	<= | (a <= b) # Меньше или равно
	>= | (a >= b) # Больше или равно
	== | (a == b) # Равно
	!= | (a != b) # Не равно
	
	!(a < b) равносильно (a >= b)

- Операторы сравнения ИЛИ / И

	|| / ((a < b) || (a < c)) # ИЛИ 

	&& / ((a < b) && (a < c)) # И 


0x250 ### ПРАКТИЧЕСКАЯ РАБОТА ###

БИБЛИОТЕКИ 

	- stdio  # /usr/include/stdio.h 
	стандартная библиотека ввода вывода в которой опеределенны
	некоторые константы и прототипы функций 

КОМПИЛЯТОР

	- GNU Compiler Collection (GCC)
	
		@ gcc firstprog.gcc # код на языке C 
		@ ls -l a.out # скомпилированная программа
		@ ./a.out # выполнить программу

ДВОИЧНЫЙ ИСПОЛНЯЕМЫЙ ФАЙЛ a.out 

	- objdump # программа для изучения скомпилированных файлов
		
		@objdump -D a.out | grep -A20 main 
			# такой вид команды будет выводить лишь 
			# следующие 20 строк после регулярного main
		
	- байты представленны в 16-ричной смстеме счмсления 
			# 0 1 2 3 4 5 6 7 8 9 A B C D E F
			# 1 byte = 8 bit 256(2^8) возможных значений
		
	- 16-ричн числа слева это адреса памяти 0x8048374
			# Биты команд машинного языка размещаются
			# в байтах памяти для временного хранения
	
	- Разрядность процессора
			# в 32-разрядн 2^32 = 4 294 967 296 адресов
			# в 64-разрядн 2^64 = 1.8446741 * 10^19 адресов
	
	- Язык ассемблера
			# На нем команды записанные справа составляют
			# набор мнемоник для соотв. машинных команд	
			- Команда ret # она же 0xc3 or 11000011
	
	- Синтаксисы Ассемблера AT&T & Intel
		# AT&T характеризуется символами % и $
		# Intel более понятный для анализа

	- @objdump -M intel -D a.out
		# Для установления пользовательского синтаксиса
		# используется опция -M с аргументом intel

	- Регистры процессора
		# Набор специальных переменных, большинство
		# инструкций пользуется этими регистрами 
		# для чтения или записи данных	


0x252 #### Процессор x86

	- GDB # отладчик для выполнения скомпилированных и
	исследования памяти программы и просматривания регистров 

		@gdb -q ./a.out # Запуск отладки программы

		(gdb) break main # точка останова перед функцией main()

		(gdb) run # запуск отладки

		(gdb) info registers # вывести содержимое регистров
	
		(gdb) quit # закрыть gdb


	- Регистры общего назначения

		RAX # Accumulator - аккумулятор 

		RCX # Counter - счетчик

		RDX # Data - регистр данных

		RBX # Base - базовый регистр


	- Указатели (индексные регистры) регистры общего назначения

		RSP # Stack Pointer - указатель стека

		RBP # Base Pointer - указатель базы

		RSI # Source Index - индекс источника

		RDI # Destination Index - индекс приемника 

		# Первые два регистра хранят 32-х разрядные адреса,
		  указываюзие местоположение в памяти. Эти регистры 
		  весьма важны для выполнения программ и управления
		  памятью

		# Последние два регистра формально тоже являются 
		  указателями обычно указывающие на источник и приемник
		  когда нужно прочитать или записать данные
		
	- Регистр EIP
		
		# Instruction Pointer - указатель команды, содержит адрес
		следующей команды для процессора, данный регистр очень важен
		и активно используется при отладке

	- Регистр EFLAGS (флагов)
		
		# содержит несколько битовых флагов, участвующих в операциях
		  сравнения и сегментации памяти


0x253 Язык ассемблера PAGE 36 

	- Внутри GDB синтаксис дизассемблирования Intel можно задать
	командой 
		@ set disassembly intel | set dis intel

	- Чтобы такая настройка действовала при каждом запуске GDB
	необходимо поместить команду "set dis intel" в файл .gdbinit
	расположенный в домащнем каталоге
		@ echo "set disassembly-flavor intel > ~/.gdbinit"

	- Команды ассемблера в синтаксисе Intel обычно имеют такой вид:
		# операция <приемник>, <источник>
		Значениями приемника и источника могут быть Регистры,
		Адрес памяти или Значение

	- Операции представляют собой интуитивные мнемоники
		
		MOV # перемещает(MOVE) значение источника в приемник

		SUB # вычитает(SUBSTRUCT) значение источника в приемник

		INC # увеличивает(INCREMENT) значение источника в приемник

	----
	
	89 e5		mov rbp, rsp # Перемещение значения из RSP в RBP

	83 ec 08	sub rsp, 0x8 # Вычесть 8 из RSP и сохранить результат в RSP
	

	- Операции управляющие потоком выполнения
		
		CMP # операция для сравнения значений 

		# а операции начинающиеся с J (jump) осуществляет переход
		в другое место кода (в зависимости от результатов сравнения)

		JLE # jump if less than or equal to - перейти если меньше
		или равно
		

		JMP # операция безусловного перехода 
	
	----

	83 7d fc 09		cmp DWORD PTR [rbp-4], 0x9
		
		# 4 байтовое значение (DWORD), находящееся в RBP, уменьшенное
		на 4, сравнивается с 9

	7e 02			jle 8048393 <main+0x1f>
		
		# Данная команда (перейти если меньше или равно) связана с
		результатом предыдущего сравнения

		-> если указанное 4-байтовое значение меньше или равно 9
		осуществляется переход к команде по адресу 0x8048393

	eb 13			jmp 80483a6 <main+0x32>

		# Данная команда (перейти по адресу) свзяна с двумя предыдущими
		командами логическое структурой

		-> если указанное 4-байтовое значение больше 9 осуществляется
		переход к команде по адресу 0x80483a6

	
	- Компилятор GCC можно запустить с флагом -g, чтобы включить в
	программу дополнительную отладочную информацию, с помощью которой
	GDB получит доступ к исходному коду

		@ gcc -g firstprog.c  # внести доп-информацию в исполняемый файл

		@ ls -l a.out # размер исполняемого файла изменится

		@ gdb -q a.out # запуск gdb

		gdb@ list # вывести исходный код на C (доп информация)

		gdb@ disassemble main # вывести результат дизассемблирования main

		gdb@ break main # точка останова main

		gdb@ run

	
	- info register rip | i r eip 
	
		# значение rip (указатель текущей команды)
	
	- i r rax | i r eax 
		
		# для 64 битных систем к регистрам можно обращаться как к 64 битному
		так и к 32:
			
			i r rax # 64
			
			i r eax # 32 
	
	- В отладчике GDB можно непосредственно изучать содерджимое 
	с помощью команды x (examine), позволяющая просмотреть разными
	способами содержимое по определенному адресу памяти 
		
		x # examine
		rip = 0x8048384

		o # Восьмеричный (octal)
			
			x/o 0x8048384 (rip address) =>	077042707
			x/o $rip    (equal prev) 	=>	077042707

		x # Шестнадцатеричный (hexadecimal)
			
			x/x $rip => 0x00fc45c7

		u # Десятичный без знака (unsigned decimal)
			
			x/u $rip => 16532935

		t # Двоичный (binary)
			
			x/t $rip => 00000000111111000100010111000111

		# Все числа на выходе эквивалентны друг другу только
		в разных системах счисления

	
	- В команде examine можно также указать число перед форматом, чтобы
	исследовать несколько блоков по целевому адресу
		
		x/2x $rip: 0x00fc45c7 0x83000000

		x/12x $rip: 0x00fc45c7 0x83000000 0x7e09fc7d 0xc713eb02
					0x84842404 0x01e80804 0x8dffffff 0x00fffc45
					0xc3c9e5eb 0x90909090 0x90909090 0x5de58955

	- По умолчанию размер одного блока равен четырем байтам, что
	составляет одно компьютерное слово. Размер отображаемых блоков
	можно изменить, добавив к имени формата букву, соответствующую размеру

		b 1 (byte), байт

			x/8xb $rip:

					0xc7 0x45 0xfc 0x00 0x00 0x00 0x00 0x83

		h Полуслово (halfword), 2 байта

			x/8xh $rip

					0x45c7 0x00fc 0x0000 0x8300 
					0xfc7d 0x7e09 0xeb02 0xc713
			
		w Слово (word), 4 байта 

			x/8xw $rip
					
					0x00fc45c7 0x83000000 0x7e09fc7d 0xc713eb02
					0x84842404 0x01e80804 0x8dffffff 0x00fffc45


		g Гигантское слово (giant), 8 байтов

			x/xg $rip
					
					0x83000000000000fc45c7
	 
	
	- Это может вызвать некоторую путаницу, поскольку иногда термином
	слово обозначают двухбайтные значения. В таких случаях двойным
	или DWORD, называют четырехбайтные значения. В данных примерах слово

		# DWORD относится к 4 байтным значениям.

		# (short) относятся к коротким словам или полусловом
	
	
	- Особенности расположения памяти
		
		Первая команда examine показывает, что первые два байта содержат
			
			0xc7 и 0x45

		Тогда как полуслово, расположенное по тому же адресу содержит

			0x45c7 # байты в обратном порядке

		Такой же эффект наблюдается в полном четырехбайтном слове
			
			0x00fc45c7
		
		Хотя по одному первые четыре байта выводятся в порядке

			0xc7 0x45 0xfc 0x00

	- Процессоры с префиксом x86 хранит значение байтов в обратном
	порядке (little-endian byte order)

		# Если четыре байта нужно интерпретировать как одно число, байты
		следует считывать в обратном порядке. Возможной путаницы можно
		избежать, отображая числа как шестнадцатеричные или как десятичные
		без знака

		x/4xb $rip
			
			0xc7 0x45 0xfc 0x00

		x/4ub $rip

			199 69 252 0
			

			# Если использовать неправильный порядок байтов, то получается
			неверный результат

			199 * (256^3) + 69 * (256^2) + 252 * (256^1) + 0 * (256^0)
			= 3343252480
			
			# Если использовать правильный порядок байтов, то получается
			верный результат

			0 * (256^3) + 252 * (256^2) + 69 * (256^1) + 199 * (256^0)
			= 16532935

		x/1xw $rip

			0x00fc45c7

		x/1uw $rip
			
			16532935


	- Команде examine можно также передать параметр формата 
	i (instruction), чтобы вывести содержимое памяти в виде команд
	ассемблера
		
		for (i = 0; i < 10; i++)
		
		x/i $rip # Вывести инструкцию по адресу регистра 
			 
			 mov DWORD[rbp-0x4],0x0
		
		x/3i $rip # Вывести следующие три инструкции по адресу регистра
			
			 mov DWORD PTR[rbp-0x4],0x0
			 cmp DWORD PTR[rbp-0x4],0x9
			 jle 0x8048393 <main+31>
		
		x/7xb $rip # 
			
			0x555555555141: 0xc7 0x45 0xfc 0x00 0x00 0x00 0x00

	- Предшествующие результаты работы OBJDUMP подтверждают, то семь
	байтов на которые указывает регистр RIP, действительно являются 
	машинным кодом соответствующих команд ассемблера
			
		1141: c7 45 fc 00 00 00 00 mov DWORD PTR [rbp-0x4], 0x0

		# Эта команда ассемблера поместит значение 0 в ячейку памяти,
		адрес которой на 4 меньше того, что содержится в регистре RIP.
		Это адрес, по которому хранится переменная i кода C;

		# i была объявлена как целое число, использующее 4 байта памяти
		в архитектуре x86. По существу, данная команда обнулит переменную
		i для цикла for

		# Если посмотреть сейчас содержимое пямяти по этому адресу, там
		обнаружится случайный мусор
	
	- Отобразить содержимое пямяти можно разными способами. Все приведенные
	ниже способы отображают 4 байта мусора в том месте памяти, которое будет
	очищено в результате выполнения текущей команды 

		i r rbp | i r $rbp 
			
			rbp 0x7fffffffe700 0x7fffffffe700

		x/4xb $rbp - 4 # содержимое в первых четырех байтах в $rbp - 4 
			
			0x7fffffffe6fc: 0x55 0x55 0x00 0x00
	
		print $rbp - 4
			
			# вывести и сохранить во временную переменную
			к какому адресу принадлежит $rbp - 4

			$1 = (void *) 0x7fffffffe6fc

		x/4xb $1 # вывести содержимое по адресу во временной переменной
			
			0x7fffffffe6fc: 0x55 0x55 0x00 0x00
		
		x/xw $1 # вывести 4-х байтовое значение по адресу в $1
			
			0x7fffffffe6fc: 0x00005555
			
	- Выполнить текущую команду можно с помощью команды отладчика
	nexti (next instuction). Процессор прочтет команду по адресу,
	находящемуся в EIP, выполнит ее и переведет EIP на следующую
	команду

		nexti # выполнить текущую инструкцию и переместить EIP
				к следующей инструкции
		
			for (i = 0; i < 10; i++)

			0x555555555148:	7 0x8d4813eb

		x/xw $1 # предыдущая инструкция изменила значение в регистре
				[rbp-0x4] (integer i) на 0 => int i = 0
			
			0x7fffffffe6fc: 0x00000000

		x/dw $1 # вывести целочисленное значение 4-х байтного регистра
			
			0 # int i = 0

		i r $rip # вывести адрес на который указывает регистр rip

			rip 0x555555555148 0x555555555148 <main+15>

		x/i $rip # вывести текущую инструкцию на которую указывает rip
			
			0x555555555148 <main+15>: jmp 0x55555555515d <main+36>
		
	- Как и ожидалось, предыдущая команда обнулила 4 байта по адресу
	EBP - 4, представляющего собой память, отведенную для переменной i
	После этого EIP	перешел к следующей команде.

		
	
	- JMP 0x55555555515d <main+36>
			
		JMP команда безусловного перехода перенаправит на следующую
		инструкцию сравнения cmp DWORD PTR [rbx-0x4],0x9
	
	- nexti
		
		for (i = 0; i < 10; i++)

	- x/i $rip

		0x000055555555515d: <main+36> cmp DWORD PTR [rbp-0x4],0x9
			
		# Команда cmp (compare) выполняет сравнение, в данном случае
		содержимого памяти, отведенной для переменной i языка С, со
		значением 9.

	- Следующая команда JLE выполняет переход при условии 
	<меньше или равно> 

		nexti
		x/i $rip 
			
			0x555555555161 <main+40>: jle 0x55555555514a <main+17>

	- При этом проверяется результат предыдущей команды сравнения
	хранящийся в регистре EFLAGS, и если он совпадает с <меньше или равно>
	то EIP перенацеливается на совсем другой участок кода.

	- В данном случае инструкция говорит, что нужно перейти по адресу
		
		if <= jump to 0x55555555514a <main+17>
		
		0x55555555514a <main+17>: lea rax,[rip+0xeb3] # 0x555555556004
		0x555555556004: rex.W

	- Если значение будет больше, то EIP укажет на следующую команду
		
		mov eax,0x0
		leave
		ret

	- Совокупность всех инструкций составляет конструкцию if-then-else
	
	
	- LEA приемник, источник (Load Effective Address)
		
		ИСТОЧНИКОМ может быть только переменная (ячейка памяти),
		а ПРИЕМНИКОМ - только регистр (но не сегментный)
		
		Если адрес 32 разрядный, а ПРИЕМНИК 16 разрядный, то старшая
		половина вычисленного адреса теряется. Если наоборот ПРИЕМНИК
		32 разрядный, а адрес 16 разрядный, то вычисленное смещение
		дополняется нулями 

	- LEA rax, [rip+0xeb3] # 
	
		
		rip + 0xeb3 == 
		0x55555555514a + 0xeb3 ==
		0x55555555514a + 0x000000000eb3 = 0x555555555ffd

	- Чтобы проверить, что именно содержится по адресу 0x55555555ffd
	используем examine and print

		print $rip+0xeb3
			
			$1 = (void *)0x555555555ffd

		x/8xb $1 # Вывести 8 байтов по сохраненному адресу

			0x00 0x00 0x00 0x01 0x00 0x02 0x00 0x48
			
			# В выводе вроде бы ничего необычного, но на самом деле
			можно заметить в последнем байте 0x48, что соответствует 
			символу 'H' по таблице ASCII. Выведем еще 8 байтов после 

		x/16xb $1 

			0x00 0x00 0x00 0x01 0x00 0x02 0x00 0x48
			0x65 0x6c 0x6c 0x6f 0x20 0x57 0x6f 0x72
			
			# Здесь уже проясняется явная картина слова 'Hello '
			
			0x48 = 'H'
			0x65 = 'e'
			0x6c = 'l'
			0x6c = 'l'
			0x6f = 'o'
			0x20 = ' '
		

	- К счастью, команда GDB examine позволяет отображать и такое
	содержимое памяти. Формат c автоматически покажет байты согласно
	таблице ASCII, а формат s покажет всю строку символьных данных
			
		nexti # выполнить текущую инструкцию и перейт к следующей
		
			# Как помнится текущая инструкция lea rax, [rip+0xeb3]
			помещает данные из адреса 0x555555555ffd, но только
			используя эффективный адрес
			
	- Если глянуть по адресу rax, можно обнаружить интересный порядок
	байтов 
		
		x/8xb $rax # Вывести 8 байтов по адресу регистра rax
			
			0x48 0x65 0x6c 0x6c 0x6f 0x20 0x57 0x6f
			
			# Очень похоже на содержимое rix+0xeb3 (0x555555555ffd)

			x/16xb $1 # (0x555555555ffd)

				0x00 0x00 0x00 0x01 0x00 0x02 0x00 0x48
				0x65 0x6c 0x6c 0x6f 0x20 0x57 0x6f 0x72

	- Теперь наконец можно увидеть долгожданное сообщение 
	в регистре $rax
		
		x/14cb $rax
			
			0x555555556004:
			72 'H' 101 'e' 108 'l' 108 'l' 111 'o' 32 ' ' 87 'W' 111 'o'
			0x55555555600c:
			114 'r' 108 'l' 100 'd' 33 '!' 32 ' ' 0 '\000'

		x/s $rax
			
			0x555555556004: "Hello World! "
	
	- Подготовка для вызова функции printf(),
		
		mov rdi, rax # поместить содержимое rax в rdi
			
			# Скорее всего следующая инструкция работает с данным
			регистром для вывода,

		x/4xw $rdi  # при попытке проверить содержимое данного регистра
			
			0x1: Cannot access memory at address 0x1 
			
			# Нет доступа к памяти 

	- Эта строка передается в качестве аргумента функции printf(), а
	следующая инструкция является вызовом функции printf()
			
		x/i $rip
			
			call 0x555555555030 <puts@plt>
				
			# Вместо вызова printf вызываетя функция puts, это обусловленно
			тем, что процессор знает, для printf будет затраченно больше
			времени, а строка переданная в printf не содержит доп аргументов
			и для тривиальных строк ему проще вызвать функцию puts@plt 
		
		nexti 
			
			Hello World!
	
	- Для осуществления итерации переменной i, находящейся по адресу
	$rbp - 4 в текущем исполняемом файле используется ADD

		add DWORD PTR [rbp-0x4], 0x1 # операция сложения 
	
		x/d $rbp - 4 # проверить значение переменной i
			
			0x7fffffffe6fc: 0

		nexti # add DWORD PTR [rbp-0x4], 0x1 ... прибавить 1 

		x/dw $rbp - 4  
		
			0x7fffffffe6fc: 1 # значение изменилось !!!
	
	- После всех действий повторно производится сравнение 
		
		cmp DWORD PTR [rbp-0x4], 0x9 
			# если результатом является <= [CF AF SF IF]
			перенос настройка знак прерывание
	
	- Если результат в eflags <=
		
		jle 0x55555555514a <main+17> # возврат в начало цикла

	  
			
0x261 Строки 

	
	- Значение "Hello World! \n", передаваемое функции printf
	в предыдущей программе, является строкой формально, массивом
	символов. Массив в C это просто список из n элементов определенного
	типа. Массив из 20 символов это 20 символов, размещенных в памяти
	один за другим. Массивы также называют буферами. Программа
	char_array.c содержит пример массива символов. 
	
		char str_a[20];
	
	-Компилятор GCC принимает ключ -o, с помощью которого можно задать
	имя выходного файла, содержащего результат компиляции. Ниже показано,
	как скомпилировать эту программу в исполняемый двоичный файд char_array.

		gcc -o char_array char_array.c 
			
			ls -l char_array

		./char_array
			
			Hello World!

	- В данной программе определен массив str_a из 20 символов, и во все
	элементы этого массива поочередно выполняется запись. Нумерация
	элементов начинается с 0, а не с 1. Кроме того, последним символом
	является 0 (null, или нулевой байт)
		
		0 | '\0'
	
	- Поскольку массив определен как символьный, ему было выделено 20 байт
	памяти, но фактически из них использовано только 12. Нулевой байт в конце
	играет роль разделителя, сообщая функциям, сообщая функциям, работающим
	с этой строкой, что в этом месте необходимо остановиться

	
	- Задавать каждый символ в массиве утомительно, а строки используются
	достаточно часто, поэтому для обработки строк был создан набор
	стандартных функций. Например функция strcpy() копирует строку из
	ИСТОЧНИКА в ПРИЕМНИК, последовательно просматривая строку источник
	и копируя каждый байт в СТРОКУ-ПРИЕМНИК (останавливаясь при
	обнаружении нулевого байта - конца строки  0 | '\0')

		char strcpy(char *dst, const char *src); # прототип strcpy
		
		*dst # destionation = ПРИЕМНИК адрес назначения 
		*src # source = ИСТОЧНИК

	- Программу char_array.c можно переписать с использованием функции
	strccpy(), так что она будет выполнять ту же задачу с применением 
	библиотеки строковых фукнций. В следующей версии программы char_array
	включается заголовочный файл STRING.H, поскольку в ней используется 
	строковая функция 

		char_array2.c 
		
		#include <stdio.h>	# printf()
		#include <string.h> # strcpy()


	
	- Изучим эту программу с помощью GDB. В приведенном ниже листинге
	скомпилированная программа открывается в отладчике, и устанавливаются
	точки останова до функции STRCPY(), на ней и после нее, что отмечено
	полужирным. Отладчик остановит выполнение программы в каждой из этих
	точек, что позволит просмотреть содержимое регистров и памяти. 
	
	- Код функции STRCPY() берется из библиотеки общего доступа, поэтому 
	задать точку останова внутри этой функции можно только после начала 
	выполнения программы

		gcc -g -o char_array2 char_array2.c # компиляция с доп инф.
		
		gdb -q ./char_array2 # отладка

			break 6 # Установить точку останова на 6 строке
			
				Breakpoint 1 at 0x80483c4: file char_array2.c line 6

			break strcpy # line 7 # установить точку останова на функции

				Function "strcpy" not defined.
				Make breakpoint pending on future shared library load? y
				Breakpoint 2 (strcpy) pending.

			break 8 
				
				Breakpoint 3 at 0x80483d7: file char_array2.c, line 8

	- При запуске программы обрабатывается точка останова STRCPY()
	В каждой точке останова рассмотрим содержимое RIP и команды, на
	которое он указывает. Обратите внимание

		run # выполнить до первого брекпоинта

			Staring program
			Breakpoint 4 at 0xb7f076f4 
			Pending breakpoint "strcpy" resolved

			Breakpoint 1, main () at char_array2.c:7
			7 strcpy(str_a, "Hello World!\n");

		i r $rip 
			
			rip 0x80483c4 0x80483c4 
	
		
		continue # перейти к следующему брекпоинту	
	
			Continuing
			Breakpoint 4, 0xb7f076f4 in strcpy () 
			from /lib/tls/i686/cmov/libc.so.6

		i r $rip 
			
			rip 0xb7f076f4 0xb7f076f4  <strcpy>

		continue
			
			Continuing
			Breakpoint 3, main () at char_array2.c:8
			8 printf(str_a)

		i r $rip 
			
			rip 0x80483d7 0x80483d7 


		x/5i $rip

	- Адрес, находящийся в EIP в средней точке останова, отличается
	от лругих, потому-что код функции strcpy() находится в загруженной
	библиотеке. В средней точке отладчик отображает EIP для кода функции
	strcpy(), тогда как в двух других точках EIP указывает на код функции
	main(). Хочу подчеркнуть, что EIP способен "переноситься" из основного
	кода в код strcpy() и обратно. При каждом вызове функции запись об этом
	сохраняется в структуре данных, называемой стеком. С помощью стека RIP
	может возвращаться из длинных цепочек вызовов функций.

	- В GDB есть функция есть команда bt (от backtrace) позволяющая
	проследить цепочку вызовов, помещенную в стек. Ниже показано состояние
	стека для каждой точки останова 


		run
			
			Breakpoint 1, main () at char_array2.c: 7
			7 strcpy(str_a, "Hello, World!\n");

		bt 
			
			#0 main () at char_array2.c:7

		cont # continue
			
			Continuing
			Breakpoint 4, 0xb7f076f4 in strcpy() from ...

		bt  # проверить стек вызовов функций
			
			#0 0xb7f076f4 in strcpy() from /usr/lib/libc.so.6
			#1 0x080483d7 in main() from char_array2.c:7

		cont 
			
			Breakpoint 3, main () at char_array2.c:8
			8 printf(str_a);

		bt
			
			#0 main () at char_array2.c:8


	- В средней точке останова обратная трассировка стека показывает
	вызов strcpy() немного изменился. Это результат действия защиты от
	эксплойтов, включаемой по умолчанию в ядро Linux начиная с версии 
	2.6.11. Несколько позднее мы подробно рассмотрим эту защиту



0x262 

### Целые числа со знаком, без знака, длинные и короткие ### 


	- По умолчанию числовые значения в C имеют знак, то есть могут быть
	как положительные так и отрицательными. Напротив, беззнаковые значения
	не могут быть отрицательными. Поскольку все это хранится, все числовые
	значения должны хранится в двоичном виде и двоичный вид беззнаковых
	значений понятнее всего.

	- 32 разрядное беззнаковое целое может принимать значения от 
		
		0 (все рарзряды нули)
			до
		4 294 967 295 (все разряды единицы)

	- 32 разрядное целое со знаком содержит те же 32 бита и, следовательно
	может быть одной из 2^32 возможных комбинаций.
		

		- 2 147 483 648 
			до
		2 147 483 647 

	
	- Положительные значения со знаком имеют тот же вид, что и беззнаковые,
	но отрицательные хранятся иначе - в так называемом дополнительном коде

	- Представление чисел в ДОПОЛНИТЕЛЬНОМ КОДЕ  удобно для работы двоичных
	сумматоров: если сложить отрицательную величину в дополнительном коде
	с положительным числом с такой же абсолютной величиной, то в результате
	получится 0. 



	- Чтобы получить запись в двоичном дополнительном коде, нужно записать
	число в двоичном виде, инвертировать все его разряды и прибавить к
	результату 1. Звучит странно, но действительно позволяет складывать
	отрицателные числа с положительными с помощью простых двоичных
	сумматоров

	- Эту арифметику легко проверить с помощью python.
	
		# Сначала мы видим, что двоичное значение 01001001
		это положительное число 73

		a = 0b0100100
		print(a)
			73 # a in decimal 
		---------------------
		
		
		# Затем инвертируем все разряды 
		
		a_reverse = 0b10110110
		print(a_reverse)
			182 # a reverse in decimal
		------------------------------


		# Прибавляем 1, чтобы получить дополнительный код для
		-73 (10110110)

		dop_code = a_reverse + 1 	
			183 # dop_code in decimal
		-----------------------------

		
		# Сложив эти две величины, получим 0 в исходных 8 разрядах
		Вывод python показывает 256, потому что не знает, что мы оперируем
		всего лишь с 8-битными числами. В двоичном сумматоре этот бит
		переноса будет отброшен, поскольку выходит за границы памяти,
		отведенной переменной.

		bin(a + dop_code) # 1[00000000]
			
			'0b100000000' # 256
		
		
		- В C можно определить переменную как беззнаковую с помощью
		ключевого слова UNSIGNED, помещаемого в объявлении перед
		именем переменной. Беззнаковое целое объявляется как UNSIGNED INT
		
		- Кроме того,  размер памяти, выделяемой числовой переменной
		можно увеличить или уменьшить с помощью ключевых слов LONG и SHORT
		Фактический размер зависит от архитектуры, для которой компилируется
		код.

		- В языке C есть оператор SIZEOF(), умеющий определять размер 
		некоторых типов данных. Он действует как функция, принимающая на 
		входе тип данных и возвращаюшая размер в целевой архитектуре
		переменной, объявляемой с таким типом.

		- Следующая программа datatype_sizes.c исследует размер данных
		с помощью функции sizeof()

			gcc datatype_sizes.c -o datatype_sizes
		
		
		- В коде программы datatype_sizes.c функция printf() исползуется
		используется несколько по-иному, чем прежде. Здесь применен так
		называемый спецификатор формата, чтобы показать значения,
		возвращаемые вызовами sizeof()


		- Как уже отмечалось, в архитектуре x86 знаковые и беззнаковые 
		целые числа занимают 4 байта. Число с плавающей точкой тоже
		занимает 4 байта, а символьному типу нужен всего 1 байт. Ключевые
		слова LONG and SHORT можно использовать и с переменными с плавающей
		точкой (DOUBLE/LONGD DOUBLE), чтобы увеличить или сократить размер.



0x263

### УКАЗАТЕЛИ ###


		
		- Регистр RIP представляет собой указатель следующей команды,
		поскольку содержит ее адрес. Идея указателей используется и в языке
		C. Поскольку физическую память реально перемещать нельзя, приходится
		копировать содержащуюся в ней информацию. Копирование больших
		блоков памяти, чтобы с ними могли работать разные функции и в 
		разных местах, требует очень больших накладных расходов. Это
		дорого обходится и с точки зрения памяти, потому что перед
		копированием нужно сохранить или выделить память для нового
		экземпляра данных. Решение данной проблемы дают указатели. Гораздо
		проще не копировать большой участок памяти, а передать адрес его
		начала

		- Указатели объявляются и используются в C так же, как переменные
		прочих типов. В архитектуре x86 применяется 32-разрядная адресация,
		поэтому указатели имеют размер 32 бита (4 байта), а в x86_64 64 бита
		(8 байтов). Указатели объявляются с помощью звездочки (*),
		помещаемой перед именем переменной. В результате указатель
		оказывается не переменной некоторого типа, а средством указания на
		данные этого типа. Программа pointer.c демонстрирует применение
		укзателей с типом данных char, имеющих размер 1 байт


			gcc -o pointer pointer.c

		
		- Как сказано в комментариях, первый указатель устанавливается на
		начало массива символов. Такая сссылка на массив фактически
		преставляет собой указатель. Выше этот буфер передавался функциям
		PRINTF() and STRCPY() именно как указатель. Второму указателю
		присваивается адрес из первого плюс 2, а затем выполняется печать 
		некоторых данных 
			
			./pointer

				Hello, World!
				llo, world!
				Hey you guys!

		
		- Посмотрим эту программу с помощью GDB. Программа компилируется,
		и задается точка останова на 12 строке исходного кода. В результате
		останова произойдет после того, как строка "Hello World!\n" будет
		скопирована в буфер str_a


			gdb -q ./pointer # отладка pointerz


			break 12
				
				Breakpoint 1 at 0x1186: file pointer.c, line 12

			run # go run to breakpoint at line 12

				Breakpoint 1, main () at pointer.c:12
				12	printf(pointer);

			x/xw pointer # посмотреть содержимое по адресу в указателе
				
				0x7fffffffe6c0: 0x6c6c6548

			x/s pointer # вывести строку по адресу в указателе 
				
				0x7fffffffe6c0: "Hello World!\n"


		- Если рассмотреть указатель как строку, то заметно, что это наша
		строка, находяшаяся по адресу 0x7fffffffe6c0. Не забываем, что в
		переменной-указателе хранится не сама строка, а только ее адрес



		- Чтобы увидеть фактические данные хранящиеся в переменной указателе
		нужно воспользоваться оператором адреса. Оператор адреса является
		унарным, то есть применяется к единственному аргументу. Он
		представяет собой всего лишь амперсанд (&), помешаемый перед
		именем переменной. При его использовании возвращается адрес этой
		переменной, а не ее значение. Этот оператор есть и в GDB, и в языке С
		
			x/xg &pointer # вывести адрес самого указателя и адрес на
							который он указывает
				
				0x7fffffffe6b0: 0x00007fffffffe6c0
				
				- Мы видим, что переменная pointer находится в памяти по
				адресу 0x7fffffffe6b0 и хранит адрес 0x7fffffffe6c0


			print &pointer
				
				$1 = (char**) 0x7fffffffe6b0

			print pointer

				$2 = 0x7fffffffe6c0 "Hello World!\n"

		
		- Оператор адреса часто используется вместе с укзаталями, поскольку
		указатели хранят адреса памяти. Программа ADDRESSOF.C демонстрирует,
		как адрес целочисленной переменной помещается в указатель.
		Соответствующая строка кода выделена полужирным.
		
			gcc -g -o addressof addressof.c	


		- Сама программа ничего не выводит, но можно сообразить, что в ней
		происходит, даже не запуская отладчик

			gdb -q ./addressof
			
			break 9 # установка break на закрывающую фигурную скобку main
					то есть в конец функции 
					
				Breakpoint 1 at 0x1164: file addressof.c, line 9

			run
			
				Breakpoint 1, main () at addressof.c:9

			
			print int_var

				$1 = 5 # число содержащееся в переменной

			print &int_var # адрес по которому находится переменая
				
				$2 = (int *) 0x7fffffffe6cc

			print int_ptr # указатель так же содержит адрес переменной
				
				$3 = (int *) 0x7fffffffe6cc

			print &int_ptr # вывести адрес указателя

				$4 = (int **) 0x7fffffffe6d0

				# 0x7fffffffe6cc + 4 = 0x7fffffffe6d0


		- Для работы с указателями есть еще один унарный оператор,
		называемый оператором разыменования (dereference). Он возвращает
		данные, находящиеся по адресу, содержащемуся в указателе, а не сам
		этот адрес. Он выглядит как звездочка перед имененем переменной,
		подобно объявлению указателя. Оператор разыменовывания тоже есть и
		в GDB с его помощью можно получить целое число, на которое
		указывает INT_PTR
			
			print *int_ptr # разыменовать адрес и вывести значение по адресу
				
				$5 = 5 
		
		- Несколько дополнив код листинга addressof2.c, продемонстрируем все
		эти понятия. В добавленных функциях printf() используется параметры
		формата, о которых я расскажу в следующем разделе. Здесь же
		ограничимся рассмотрением результата работы программы

			gcc -o addressof2 addressof2.c 
		
		- В результате компиляции и запускаполучается следующий вывод:

			int_ptr = 0x5fecaf8c
			&int_ptr = 0x5fecaf90
			*int_ptr = 0x00000005

			int_var is located at 0x5fecaf8c and contains 5
			int_ptr is located at 0x5fecaf90, contain 0x5fecaf8c,
			and points to 5 

		- Применяя унарные операторы к указателям, можно представлять себе
		что опертор адреса перемещает нас назад, а оператор разыменовывания
		вперед по направлению указателя

	
0x264 Форматные строки 	

		
		- Функция printf() позволяет не только выводить фиксированные строки
		Применяя в ней форматные строки, можно печатать переменные в
		различных форматах. Форматная строка - это строка символов со
		специальными управляющими последовтельностями, или escape-последов.
		указывающими функции на необходимость разместить на месте этих
		управляющих последовательностей переменные в заданом формате

		- Каждый параметр форматирования начинается с символа процента (%)
		и содержит односимвольное сокращение, весьма похожее на символы 
		форматирования, применяемые в команде examine отладчика GDB

			- %d	Десятичный

			- %u	Беззнаковый десятичный

			- %x 	Шестнадцатеричный

		- Все указанные параметры форматирования получают даныне в виде
		значений, а не указателей. Однако есть параметры форматирования,
		которые предполагают применение указателей, например:

			- %s	Строка
				
				# Параметр форматирования %s предполагает передачу адреса
				памяти: он выводит данные начиная с этого адреса, пока не
				встретится нулевой байт.

			- %n	Количество выведенных байтов
	
				# Параметр форматирования %n является уникальным, поскольку
				он записывает данные. Он также предполагает передачу адреса
				памяти, по которому записывает данные. Он также предполагает
				передачу адреса памяти, по которому записывает количество
				выведеных к данному моменту байтов

		- Сейчас интересуют только параметры форматирования, применяемые
		для вывода данных. Программа FMT_STRING.C содержит примеры
		использования различных параметров форматирования
		
			gcc -o fmt_string fmt_string.c

		
		- В этом коде для каждого параметра в форматной строке функции
		printf() передается в качестве аргумента дополнительная переменная,
		В последнем вызове printf() участвует аргумент &A, который передает
		адрес переменной A. Ниже приведен результат компиляции и выполнения
		программы
			
			./fmt_string
			
			[A] Dec: -73, Hex: ffffffb7, Unsigned: 4294967223
			
			# Когда переменная A выводится с параметром форматирования %u,
			ее значение оказывается очень большим. Это происходит потому,
			что отрицательное число A хранится в дополнительном коде, а
			параметр форматирования пытается вывести его так, как если бы
			это было беззнаковое значение. Поскольку дополнительный код
			образуется инвертированием всех битов и прибавлением единицы,
			прежние нулевые старшие биты превращаются в единицы
			
				python

				a = 73
				bin(a)
					
					0b1001001
				
				a = 0b00000000000000000000000001001001
				
				len(a)
					
					32

				print(a)

					73

				a_invert = 0b11111111111111111111111110110110
				a_dop_code += a_invert + 1

				print(a_dop_code)
					
					4294967223

				
			[B] Dec: 31337, Hex: 7a69, Unsigned: 31337
			[field width on B] 3: '31337', 10: '     31337', '00031337'

			# Строка [field width ... показывает, как в параметре
			форматирования задается ширина поля. Это просто целое число,
			задающее минимальную ширину поля для данного параметра. Однако
			максимульную ширину поля оно не определяет: если выводимое
			значение больше, чем допускает ширина поля, она будет увеличена
			Так происходит, например, когда задана ширина поля 3, а для
			вывода данных нужно 5 байт. Если задать ширину поля 10, то перед
			данными будет выведено 5 пробелов. Кроме того, если ширина поля
			начинается с 0, поле будет дополнено нулями. Например, при
			заданной ширине поля 08 выводится 00031337 

			[string] sample Address 4f210fee
			variable A is at address: 04f210fe4

		

		- Строки форматирования применяются в целом семействе стандартных
		функций ввода/вывода, включая scanf(), которая похожа на printf()
		но служит для ввода, а не вывода. Важное отличие SCANF() состоит
		в том, что все ее аргументы являются указателями, поэтому ей нужно
		передавать не сами переменные, а их адрес. Это можно сделать с
		помощью. Это можно сделать с помощью переменных-указателей или
		применения унарного оператора адреса к обычным переменным. Программа
		input.c иллюстрирует это. 

			gcc -o input input.c 
			
		- В программе input.c функция scanf() служит для установки значения
		переменной count. Ниже демонстрируется работа этой программы.

			./input
				
				Repeat how many times? 3
				  0 - Hello World!
				  1 - Hello World!
				  2 - Hello World!

0x265

### Привидение типа ###

	
		
		- Привидение типа (typecasting) - это способ временно изменить
		тип данных, хранящийся в переменной, на другой, отличный от ее
		первоначального объявления. Приведение типа переменной есть
		указание компилятору обрабатывать ее так, как если бы она имела
		заданный новый тип, но только на время выполнения текущей операции
		Синтаксис приведения типа имеет следующий вид.
			
			(новый тип данных) переменная

		- Привидением типа можно воспользоваться, когда нужно обработать
		целые числа и числа с плавающей точкой, что демоснтрирует программа
		typecasting.c 

			gcc -o typecasting typecasting.c
			./typecasting
				
				[integers]		a = 13 b = 5
				[float]			c = 2.000000	d = 2.600000

		- Как уже говорилось, деление целого числа 13 на 5 даст неверный
		округленный результат 2, даже если записывать его в переменную
		с плавающей точкой. Однако если привести эти целочисленные
		переменные к типу с плавающей точкой, они будут обрабатываться как
		действительные числа, и мы получим правильный результат 2.6


		- Это наглядный пример, но еще более ярко привидение типа
		проявляет себя при работе с переменными-указателями. Несмотря на то
		что указатель - это всего лишь адрес памяти, компилятор C требует
		указывать тип данных для всех указателей. Отчасти это вызвано
		стремлением предотваритить ошибки программистов. Указатель на целый
		тип должен указывать на целочисленные данные, а указатель на
		символьный тип - только на символьные. Другая причина - арифметика
		указателей. Целое число занимает четыре байта, а символ - всего один
		Программа pointer_types.c иллюстрирует и объясняет эти понятия. В ее
		коде используется параметр форматирования %p, задающий вывод адреса
		памяти. Это сокращенное обозначение формата для вывода указателей,
		практически равносильного формату 0x%08x. 


			gcc -o pointer_types pointer_types.c

		- Несмотря на то что к int_pointer и char_pointer добавляется в
		циклах одно и то же число 1, компилятор увеличивает хранящиеся 
		в указателях адреса по-разному. Тип CHAR занимает 1 байт, поэтому
		указатель на следующий символ будет больше на 1 байт. А тип INTEGER
		4 байта, поэтому указатель на следующее целое число будет больше на
		4 байта

			./pointer_types

			0x7ffce2f95610 : 1
			0x7ffce2f95614 : 2		
			0x7ffce2f95618 : 3		
			0x7ffce2f9561c : 4		
			0x7ffce2f95620 : 5

			0x7ffce2f95633 : 'a'  		
			0x7ffce2f95634 : 'b'		
			0x7ffce2f95635 : 'c'		
			0x7ffce2f95636 : 'd'		
			0x7ffce2f95637 : 'e'	

		- В программе pointer_types2.c указатели преобразованы так, чтобы
		указатель на целый тип int_pointer указывал на символьные данные
		и наоборот. Ниже показаны предупредительные сообщения, выдаваемые
		компиоятором

			gcc -o pointer_types2 pointer_types2.c 
				
			pointer_types2.c: In function 'main'
			pointer_types2.c:14:22: warning:
			assignment to ‘char *’ from incompatible pointer type ‘int *’
			char_pointer = int_array;
			
			pointer_types2.c:15:21: warning:
			assignment to ‘int *’ from incompatible pointer type ‘char *’
			int_pointer = char_array;

		- Пытаясь помешать появлению ошибки в программе, компилятор
		предупреждает, что указатели указывают на несовместимые типы
		ланных. Но тип указателя волнует только компилятор и, возможно,
		только программиста. В скомпилироанном коде указатель - всего лишь
		адрес памяти, поэтому компилятор скомпилирует код, даже если
		указатель указывает на несовместимый тип данных, - он лишь
		предупреждает программиста, что результат работы программы может
		оказаться неожиданным

			./pointer_types2 
			
			0x7ffce2f95610 : 'a'
			0x7ffce2f95614 : 'e'		
			0x7ffce2f95618 : '='		
			0x7ffce2f9561c : 'Z'		
			0x7ffce2f95620 : 

			0x7ffce2f95633 : 1  		
			0x7ffce2f95634 : 0		
			0x7ffce2f95635 : 0		
			0x7ffce2f95636 : 0		
			0x7ffce2f95637 : 2

		- Несмотря на то что int_pointer указывает на символьные данные,
		содержащие 5 байт данных, он сохраняет тип указателя на целое. Это
		означает, что прибавление к указателю 1 будет увеличивать адрес на 4
		Аналогично и char_pointer будет каждый раз увеличиваться всего на 1,
		и проход через 20 байт целочисленных данных (5 - 4-байтных чисел)
		будет осуществляться по одному байту, мы снова убеждаемся, что данные
		храняся в порядке "сначала младщий байт", 4 байтное число 0x00000001
		хранится в памяти как байты 0x01 0x00 0x00 0x00
		
		
		- Мы будем сталкиваться с подобными ситуациями, когда указатель
		указывает на данные несовместимого с ним типа. Поскольку тип
		указателя определяет размер данных, на которые он указывает, нужно
		следить за правильностью типа. pointer_types3.c показывает как можно
		изменить тип переменной "на лету"
			
			gcc -o pointer_types3 pointer_types3.c 

		- В этом коде при начальном задании значений указателей происходит
		привидение типа данных к типу данных указателя. В результате
		компилятор C перестанет сообщать о конфликте типов данных, но
		арифметика указателей все равно будет работать неккоректно. Чтобы
		исправить положение, при добавлении 1 к указателю нужно сначала
		привести его к нужному типу данных, чтобы адрес увеличился на
		правильную величину. После этого нужно снова вернуть первоначальный
		тип данных указателя. Не очень изящно, но действует
			
			./pointer_types3 
			
			0x7ffce2f95610 : 1
			0x7ffce2f95614 : 2		
			0x7ffce2f95618 : 3		
			0x7ffce2f9561c : 4		
			0x7ffce2f95620 : 5

			0x7ffce2f95633 : 'a'  		
			0x7ffce2f95634 : 'b'		
			0x7ffce2f95635 : 'c'		
			0x7ffce2f95636 : 'd'		
			0x7ffce2f95637 : 'e'	

		- Конечно, гораздо проще сразу выбрать для указателя правильный 
		тип данных, однако иногда желательно иметь некий общий указатель
		без типа. В С такой указатель без типа определяется с помощью
		ключевого слова void

		- В ходе экспериментов с такими указалями быстро выясняются 
		некоторые их особенности

			# Во первых, нельзя разыменовать указатель, если у него нет
			типа

			# Во вторых указатель void нужно привести к какому нибудь типу,
			чтобы выполнять с ним арифметические действия 


		- Программу pointer_types3.c можно модифицировать так, чтобы в ней
		использовался один указатель void, приводимый к нужному типу при
		каждом его использовании. Компилятор знает, что у указателя void
		нет типа, и позволяет присвоить ему любой указатель без привидения
		типа. Однако при разыменовывании указателя void необходимо выполнить
		приведение его типа. Все это показано в листинге pointer_types4.c
		где используеутся указатель void 
		
			gcc -o pointer_types4 pointer_types4.c 
			

		- В результате компиляции и выполнения программы pointer_types4.c
		получаем:
			
			./pointer_types4

			0x7ffdc8fa5fa3 : 'a'
			0x7ffdc8fa5fa4 : 'b'
			0x7ffdc8fa5fa5 : 'c'
			0x7ffdc8fa5fa6 : 'd'
			0x7ffdc8fa5fa7 : 'e'

			0x7ffdc8fa5f80 : 1
			0x7ffdc8fa5f84 : 2
			0x7ffdc8fa5f88 : 3
			0x7ffdc8fa5f8c : 4
			0x7ffdc8fa5f90 : 5

		
		- Компиляция и вывод программ pointer_types4 и pointer_types3
		выглядит одинаково. Указатель void всего лишь хранит адрес памяти
		а приведение типа сообщает компилятору, какой тип указателя должен
		использоваться в каждом случае.

		- Поскольку нужный тип устанавливается путем приведения, указатель
		void это всего лишь адрес памяти. Если тип данных задается с
		помощью приведения типа, значит в роли указателя void можно
		испоьзовать любой тип, размер которого позволяет хранить четыре байта
		данных. В программе pointer_types5 для хранения адреса используется
		беззнаковое целое 

			gcc -o pointer_types5 pointer_types5.c 


		- Это уже почти хакинг, но поскольку при присваивании и
		разыменовании целочисленное значение приводится к нужному типу,
		конечный результат остается тем же самым

		- Обращаю внимание: вместо многократного приведения типа
		беззнакового целого для выполнения арифмитических действий над
		указателями используется функция sizeof() и обычная арифметика,
		что приносит тот же самый результат 

			./pointer_types5
			
			0x7fff6d05d6e3 : 'a'
			0x7fff6d05d6e4 : 'b'
			0x7fff6d05d6e5 : 'c'
			0x7fff6d05d6e6 : 'd'
			0x7fff6d05d6e7 : 'e'
			
			0x7fff6d05d6c0 : 1
			0x7fff6d05d6c4 : 2
			0x7fff6d05d6c8 : 3
			0x7fff6d05d6cc : 4
			0x7fff6d05d6e7 : 5

		- Работая с переменными в C, нужно помнить, что их тип интересн
		только компилятору. После того как программа скомпилированна,
		переменные представляют собой всего лишь адреса памяти. Это
		означает, что переменные одного типа можно заставить вести себя
		как переменные другого типа, заставив компилятор выполнить
		соответствующее приведение типа

	
0x266

### Аргументы командной строки ### 

	
		- Программы, работающие в текстовом режиме, часто получают
		входные данные в виде аргументов командной строки. В отличие
		от ввода с помощью scanf(), аргументы командной строки не
		требует взаимодействия с пользователем после запуска программы.
		Часто такой метод ввода оказывается эффективнее и удобнее

		В С доступ к аргументам командной строки можно получить через
		функцию main(), указав для нее два дополнительных аргумента: целое
		число и указатель на массив строк. Целое число задает количество
		аргументов командной строки, а массив строк хранит все эти 
		аргументы. Это иллюстрирует программа commandline.c

			gcc -o commandline commandline.c

		- Нулевой аргумент массива всегда содержит имя исполняемой программы
		а остальные аргументы из массива(часто называемого вектором
		аргументов) представляет собой строки с аргументами, переданными
		программе

			./commandline 1 21 121

			There were 4 arguments provided:
			argument #0	- ./commandline
			argument #1	- 1
			argument #2	- 21
			argument #3	- 121


		- Иногда программе нужно использовать аргумент командной строки
		как число, а не как строку. При этом аргументы все равно передаются
		в качестве строки, но есть стандартные функции преобразования. В
		отличие от простого приведения типа, эти функции могут действительно
		преобразовать массив символов, которым записано число, в настоящее
		число. Чаще всего используется функция atoi() (от ASCII to integer),
		преобразующая ASCII-код в целое. Она принимает в качестве аргумента
		указатель на строку, а возвращает целое число, представленное этой
		строкой. Ее работу можно изучить на примере программы CONVERT.c 
		
			gcc -o convert convert.c

		- Ниже приведен результат компиляции и выполнения программы convert.c

			
			./convert 

				Usage: ./convert <message> <# of times to repeat>

			./convert "Hello, World!" 3

				Repeating 3 times..
					
				0 - Hello, World!
				1 - Hello, World!
				2 - Hello, World!

		- Прежде чем этот код будет работать со строками, оператор if
		проверяет наличие не менее трех аргументов. Если программа
		попытается обратиться к несуществующему или запрещенному для доступа
		адресу памяти, она аварийно завершится. В программах на C необходимо
		проверять возникновение таких ситуаций и обрабатывать их. Если
		закоментировать оператор IF, в котором проверяется ошибка, можно 
		исследовать, что происходит при нарушении правильного доступа к 
		памяти. Это показано в программе convert2.c  

			gcc -g -o convert2 convert2.c

		- Ниже приведен рузультат выполнения convert2 

			./convert2 "Hello, World!" 3
				
				Repeating 3 times...

				0 - Hello, World!
				1 - Hello, World!
				2 - Hello, World! 

			./convert2 "Hello, World!" 
				
				Segmentation fault (core dumped)

			./comvert2
				
				Repeating 0 times...

		- Если не передать программе достаточное количество аргументов, она
		все равно попытается обратиться к элементам массива аргументов, даже
		если их нет. В результате программа аварийно завершится из-за ошибки
		сегментирования

		- Памяти разбита на СЕГМЕНТЫ (о которых будет говориться ниже),
		некоторые адреса памяти выходят за границы сегментов, доступ к 
		которым разрешен программе. При попытке обращения по адресу,
		выходящему за границы, программа аварийно завершается с сообщением об
		ошибке сегментации (segmentation fault). Это событие можно
		дополнительно исследовать с помощью GDB 

			gdb -q ./convert2 

			run "Hello, World!" # Запуск отладки с аргументом 

				Program received signal SIGSEGV, Segmentation fault.
				0x00007ffff7de4af0 in ____strtoll_l_internal () 
				from /usr/lib/libc.so.6
			
			where # иногда отображает полезную обратную трассировку стека
				
				#0  0x00007ffff7de4af0 in ____strtoll_l_internal ()
				from /usr/lib/libc.so.6

				#1  0x00007ffff7de1694 in atoi () from /usr/lib/libc.so.6

				#2  0x00005555555551ac in main ()

			break main # повтор отладки с брекпоинтом main
			run "Hello, World!"
				
				Start it from the beginning: y

				Breakpoint 1, main (argc=2, argv=0x7fffffffe7b8)
				at convert2.c:17
				17		count = atoi([2]);

			
			cont # продолжить выполнение
				
				Program received signal SIGSEGV, Segmentation fault.
				# По видимому segfault срабатывает при разыменовывании 
				argv[2]

			x/3xg 0x7ffffffe7b8
			
				0x7fffffffe7b8: 0x00007fffffffea9d 0x00007fffffffeac8
				0x7fffffffe7c8: 0x0000000000000000

			x/s 0x00007fffffffea9d
				
				"/home/mwuckert/Desktop/hack/0x266/convert2"

			x/s 0x00007fffffffeac8
				
				"Hello, World!" 

			x/s 0x0000000000000000
				
				0x0: <error: Cannot access memort at address 0x0>
				# Именно на третьем аргументе argv[2] = 0x0, при попытке
				разыменовать *(0x0) будет segfault 

		
		- Поскольку вектор аргументов является указателем на список строк,
		фактически он является указателем на список указателей. Проверив с 
		помощью команды x/3xw первые три адреса, хранящиеся по адресу ветора
		аргументов, мы видим, что они сами являются указателями на строки.
		Первый из них - это нулевой аргумент, второй - аргумент "Hello, World"
		а третий - ноль, который выходит за границы разрешенной памяти. При
		попытке обратиться по этому адресу программа аварийно завершается с
		сообщением об ошибке сегментации

	
0x267  

### Область видимости переменных ###


		- Еще одно интересное понятие, касающееся памяти в C, это область
		видимости, или контекст - а именно контекст переменных внутри функции
		У каждой функции есть собственный набор локальных переменных,
		независимых от всего остального. Фактически, если одна функция
		вызывается многократно, то каждый вызов происходит в отдельном
		контексте. Быстро убедиться в этом можно на примере функции printf()
		с форматными строками в программе scope.c 

			gcc -o scope scope.c 

		- Работа этой простой программы демонстрирует выполнение вложенных
		вызовов функций

			./scope

				[in main] i = 3
					[in func1] i = 5
						[in func2] i = 7
							[in func3] i = 11
						[back in func2] i =7
					[back in func1] i =7
				[back in main] i =7
						

		- В каждой функции переменной i присваивается новое значение и
		выводится на экран. Обратите внимание: внутри функции main()
		значение i равно 3 даже после вызова func1(), в которой значение
		i = 5. Аналогично в функции func1() переменная i сохраняет значение 5
		даже после вызова func2(), где она получает значение 7, и так далее
		Правильным будет считать, что в каждом вызове функции действует своя
		версия переменной i

		- Переменные могут также иметь глобальную область видимости, что
		означает их действие во всех функциях. Глобальными становятся
		переменные, объявленные в начале кода вне тела какой-либо функции.
		В программе scope2.c переменная J объявлена как глобальная и получает
		значение. Чтение и запись этой переменной можно осуществлять в любой
		функции, и эти изменения отражаются на всех функциях

			gcc -o scope2 scope2.c

		- Результат выполнения scope2.c
			
			./scope2

				[in main] i = 3, j = 42
					[in func1] i = 5, j = 42
						[in func2] i = 7, j = 42
						[in func2] setting j = 1337
							[in func3] i = 11, j = 999
						[back in func2] i = 7, j = 1337
					[back in func1] i =7, j = 1337
				[back in main] i =7, j = 1337


		- Мы видим, что глобальной переменной j в функции func2()
		присваивается значение, которое используется во всех функциях, кроме
		func3(), где есть собственная переменная с именем j. В подобном
		случае компилятор предпочитает использовать локальную переменную.
		Если переменные имеют одинаковые имена, может возникнуть путаница, но
		нужно помнить, что все это связано с паматью. Глобальная переменная j
		хранится в памяти, доступ к которой есть у каждой функции. Локальные
		переменные отдельной функции хранятся в особом участке памяти,
		несмотря на совпадение их имен с именами глобальных переменных. Если
		вывести адреса этих переменных, можно лучше понять, что происходит.
		Например, в коде программы scope3.c адреса переменных выводится
		с помощью унарного оператора адреса
			
			gcc -o scope3 scope3.c

		- Результат выполнения scope3.c

			./scope3
			[in main] i @ 0xca59cb34 = 3
			[in main] j @ 0x1b527040 = 42
				[in func1] i @ 0xca59cb14 = 5
				[in func1] j @ 0x1b527040 = 42
					[in func2] i @ 0xca59caf4 = 7
					[in func2] j @ 0x1b527040 = 42
					[in func2] setting j = 1337
						[in func3] i @ 0xca59cad0 = 11
						[in func3] j @ 0xca59cad4 = 999
					[back in func2] i @ 0xca59caf4 = 7
					[back in func2] j @ 0x1b527040 = 1337
				[back in func1] i @ 0xca59cb14 = 5
				[back in func1] j @ 0x1b527040 = 1337
			[back in main] i @ 0xca59cb34 = 3
			[back in main] j @ 0x1b527040 = 1337

		
		- Очевидно, что переменная j, используемая в func3(), отличается от
		j в других функциях. Переменная j из функции func3() хранится по
		адресу 0xca59cad4, а переменная j из остальных функций - по адресу
		0x1b527040. Обратите также внимание на то, что у каждой функции есть
		своя переменная i, - адреса этих переменных разные

		- В следующем листинге видно, что GDB останавливает выполнение в
		точке останова на функции func3(). После этого команда backtrace
		показывает все вызовы функции, записанные в стеке 

			gdb -q ./scope3

			list 1 # вывести листинг кода с первой строки
				
				...	
				7	int i = 11, j = 999;
				8	printf("\t\t\t[in func3] i @ 0x%08x = %d\n", &i, i);
				...
			
			break 8 # точка останова после присваивания значений

			run 
			
				[in main] i @ 0xca59cb34 = 3
				[in main] j @ 0x1b527040 = 42
					[in func1] i @ 0xca59cb14 = 5
					[in func1] j @ 0x1b527040 = 42
						[in func2] i @ 0xca59caf4 = 7
						[in func2] j @ 0x1b527040 = 42
						[in func2] setting j = 1337
				
				Breakpoint 1, func3 () at scope3.c:8

			bt # вывести backtrace
				
				#0  func3 () at scope3.c:8
				#1  0x0000555555555256 in func2 () at scope3.c:19
				#2  0x000055555555531d in func1 () at scope3.c:29
				#3  0x00005555555553e4 in main () at scope3.c:39

		-  Обратная трассировка показывает также вложенные вызовы
		функций по записям, хранящимся в стеке. При каждом обращении
		к функции в стек помешается запись, называемая кадром стека
		(stack frame). Каждая строка в обратной трассировке
		соответствует кадру стека. Каждый кадр стека также хранит
		локальные переменные для данного контекста. Локальные
		переменные кадров стека можно показать в GDB, если добавить
		в команду backtrace слово full
			
			bt full # полная трассировка кадров стека
				
				#0  func3 () at scope3.c:8
					i = 11
					j = 999
				#1  0x0000555555555256 in func2 () at scope3.c:19
					i = 7
				#2  0x000055555555531d in func1 () at scope3.c:29
					i = 5
				#3  0x00005555555553e4 in main () at scope3.c:39
					i = 3

		- Полная обратная трассировка подтверждает, что локальная переменная
		j есть только в контексте func3(). В контекстах других функций
		используется глобальная версия переменной j

		- Помимо глобальных, есть статичекие переменные, определяемые 
		добавлением в объявление переменной ключевого слова static. Подобно
		глобальным, статические переменные сохраняют свое значение между 
		вызовами функции; однако они похожи и на локальные, поскольку
		остаются локальными внутри контекста конкретной функции. Особым и
		уникальным свойством статических переменных является то, что они
		инициализируются только один раз. Все сказанное иллюстрирует код
		static.c 

			gcc -o static static.c
		
		- Переменная static_var объявлена статической в двух местах: 
		в контексте main() и в контексте function(). Поскольку статические
		переменные являются локальными в контексте конкретной функции, можно
		дать им одинаковые имена, но в действителности они будут представлять
		два разных адреса в памяти. function просто выводит значения этих
		двух переменных в своем контексте и добавляет к обеим 1.
		Скомпилировав и выполнив эту программу, мы увидим разницу между
		статическими и не статическими переменными

			./static
				
				[in main] static_var = 1337
					[in function] var = 5
					[in function] static_var = 5
				[in main] static_var = 1337
					[in function] var = 5
					[in function] static_var = 6
				[in main] static_var = 1337
					[in function] var = 5
					[in function] static_var = 7
				[in main] static_var = 1337
					[in function] var = 5
					[in function] static_var = 8
				[in main] static_var = 1337
					[in function] var = 5
					[in function] static_var = 9
		
		- Обратите внимание: static_var сохраняет свое значение между
		последовательными вызовами function(). Это происходит потому, что
		статические переменные сохраняют свои значения, и потому, что их
		инициализация выполняется только один раз. Кроме того, поскольку
		статические переменные являются локальными в контексте конкретной
		функции, static_var в контексте main() всегда сохраняет значение 1337
		

		- И снова, выведя адреса этих переменных с помощью оператора адреса
		мы получим лучшее представление о происходящем. Возьмем, например,
		программу static2.c 
		
			gcc -o static2 static2.c 
			./static2 
				
				[in main] static_var @ 0x562a7934b03c = 1337
					[in function] var @ 0x7ffede34d3f4 = 5
					[in function] static_var @ 0x562a7934b038 = 5
				[in main] static_var @ 0x562a7934b03c = 1337
					[in function] var @ 0x7ffede34d3f4 = 5
					[in function] static_var @ 0x562a7934b038 = 6
				[in main] static_var @ 0x562a7934b03c = 1337
					[in function] var @ 0x7ffede34d3f4 = 5
					[in function] static_var @ 0x562a7934b038 = 7
				[in main] static_var @ 0x562a7934b03c = 1337
					[in function] var @ 0x7ffede34d3f4 = 5
					[in function] static_var @ 0x562a7934b038 = 8
				[in main] static_var @ 0x562a7934b03c = 1337
					[in function] var @ 0x7ffede34d3f4 = 5
					[in function] static_var @ 0x562a7934b038 = 9
		
		- По выведенным адресам переменных видно, что static_var в main()
		отличается от переменной с тем же именем в function(), потому что у
		них разные адреса памяти (0x562a7934b03c 0x562a7934b038 соотв.) Вы,
		наверное заметили, что адреса локальных переменных намного больше
		например 0x7ffede34d3f4, а глобальных и статических - намного меньше
		например 0x562a7934b03c 0x562a7934b038. Для этого нужна
		наблюдательность, обнаружение таких мелких фактов и выяснение причин
		их появления составляет один из краеугольных камней хакинга...
		сегментация памяти...



0x270

### Сегментация памяти ### 

	
		- Память, занимаемая скомпилированной программой, делится на пять
		сегментов: 
			
			- текст или код (TEXT)

			- данные (DATA), BSS

			- куча (HEAP)

			- стек (STACK)

		- Каждый сегмент представляет собой особый раздел памяти, выделенный
		для специальных целей


		- Сегмент TEXT, выполнение команд в этом сегменте происходит
		нелинейно. При запуске программы EIP устанавливается на первую
		инструкцию в сегменте text. Затем процессор осуществляет цикл
		исполнения, в котором происходит следушее:
			
			# Считывается команда по адресу, находящемуся в EIP

			# К EIP прибавляется длина этой команды в байтах

			# Выполняется команда, прочитанная на шаге 1

			# Происходит переход к шагу

			- Если команда выполняет переход или вызов, она заменяет EIP
			другим адресом. Процессору это безразлично, потому что он не
			ориентирован на линейное выполнение команд. Если на шаге 3 EIP
			измениться, процессор перейдет к шагу 1 и прочтет ту инструкцию,
			которая находится по адресу, записанному в EIP.

			- В сегменте TEXT запись запрещенна: в нем хранится только код,
			но не переменные. Это защищает код программы от модификации: 
			при попытке записи в этот сегмент памяти программа сообщает 
			пользователю, что происходит нечто неладное, и завершает свою
			работу. Другое преимущество доступности этоо сегмента лишь для
			чтения состоит в том, что несколько запущенных экземпляров одной
			программы могут использовать его совместно, не мешая один другому.
			Следует также отметить, что размер этого сегмента памяти
			постоянен, потому что в нем не происходит никаких изменений


		- Сегмент данных и сегмент BSS предназначены для хранения глобальных и
		статических переменных программы. В сегменте DATA хранятся
		инициализированные глобальные и статические переменные, а в BSS такие
		же переменные без инициализации. Эти сегменты доступны для записи, но
		их размер также фиксирован. Вспомним, что глобальные переменные
		сохраняются независимо от функционального контекста. 
			
			# Эти сегменты доступны для записи, но их размер также фиксирован

			# Глобальные переменные сохраняются независимо от функционального
			контекста

			# Глобальные и статические переменные способны сохранять свои
			значения, поскольку хранятся в отдельных сегментах памяти


		- Сегмент кучи HEAP	непосредственно доступен программисту. Он может
		выделять в этом сегменте блоки памяти и использовать их по своему
		усмотрению
			
			# Примечательная особенность кучи - ее непостоянный размер 
			способный увеличиваться или уменьшаться по мере необходимости.

			# Память в куче управяется алгоритмами 
				
				выделения (allocator) 
					# резервирует участки памяти для использования

				освобождения (deallocator)
					# освобождает зарезервированный участок памяти
					для повторного использования 
			
			# Увеличение размеров кучи сопровождается ее ростом вниз, в
			напралении старших адресов. 


		- Сегмент стека STACK - тоже переменного размера; он служит временным
		хранилищем локальных переменных и контекстов функций при их вызове.
		Именно его показывает команда обратной трассировки в GDB. Когда
		программа вызывает некоторую функцию, та получает собственный набор
		переданных ей переменных, а код функции располагается по отдельному
		адресу в сегменте текста (код). Посколку при вызове функции 
		изменяются контекст и EIP, в стек помещаются передаваемые переменные,
		адрес, к которому EIP должен вернуться по завершении работы функции,
		и локальные переменные этой функции. Все эти данные хранятся вместе
		на стеке в так называемом кадре стека. Стек содержит много кадров

			- FILO (правило стека First Input Last Output), согласно которому
			первый объект помещенный на стек, будет последним, взятым с него
				
				pushing # помещение элемента в стек (проталкивание)

				popping # извлечение элемента из стека (выталкивание)

			- Сегмент стека в памяти является стековой структурой, хранящий
			кадры (фреймы стека).
				
				# Адрес вершины стека хранится в RSP, он постоянно изменяется
				по мере помещения в стек новых элементов и их извлечения.

				# Ввиду столь высокой динамики стека вполне логично, что его
				размер не фиксирован

				# В отличии от кучи, При увеличении рамера стека его вершина
				движется 'вверх' в направлении младших адресов 

			- Порядок FILO, действующий в стеке, может показаться странным,
			однако он очень удобен для хранения контекста 
				
				регистр RBP указатель кадра(frame pointer, FP) или
				указателем локальной базы(local base, LB)
					
					# Служит для обращения к локальным переменным функции
					располагающимся в текущем кадре стека.


			- В каждом кадре стека содержатся переданные функции параметры,
			ее локальные переменные и два указателя, необходимых для того,
			чтобы вернуть все на место: 
				
				сохраненный указатель кадра (saved frame pointer, SFP)

				адрес возврата

			- С помощью SFP регистр RBP возвращается в исходное состояние, 
			а с помощью адреса возврата в EIP записываются адрес команды,
			следующей за вызовом функции. В результате восстанавливается
			функциональный контекст предшествующего кадра стека

		
		- Приведенный ниже код stack_example.c содержит две функции: main()
		test_function() 
		
			gcc -g -o stack_example stack_example.c

		- Сначала эти программы определяют функцию test_function с четыремя
		целочисленными аргументами: a, b, c, d. Локальные переменные функции
		это 4-байтная переменная flag и 10-символьный буфер buffer. Память
		этим переменным выделяется в сегменте стека, а машинные команды кода
		функции хранятся в сегменте TEXT. Скомпилировав программу, можно
		изучить ее внутренне устройство с помощью GDB. Ниже показан результат
		дизассемблирования машинных команд для функций main() и test_function
		начинается: 
			
			main() 0x000000000000117e, 
			test_function() 0x0000000000001139
		
		- Первые несколько команд в каждой функции (в следующем листинге
		выделены полужирным) организуют кадр стека. В совокупности эти
		команды называется прологом процедуры или прологом функции. 
			
			main()
			---
			push rbp
			mov rbp, rsp 
			---
			
			test_function()
			---
			push rbp
			mov rbp,rsp
			sub rsp,0x30
			---

		Они записывают в стек указатель кадра и локальные переменные. Иногда
		в прологе функции выполняется также некоторое выравнивание стека. 
		Точный вид пролога может весьма различаться в зависимости от
		компилятора и его опций, но общая задача его команд - выстроить кадр
		стека. В совокупности эти команды называются прологом процедуры или
		прологом функции. Они записывают в стек указатель кадра и локальные
		переменные. Иногда в прологе функции выполняется также некоторое
		выравнивание стека. Точный вид пролога может весьма различаться в
		зависимости от комиилятора и его опций, но общая задача его команд -
		выстроить кадр стека 
			
			./stack_example

		- При вызове функции test_function() из main() в стек помещаются
		различные значения, образующие начало кадра стека. При этом аргументы
		функции проталкиваются в стек в обратном порядке (по-скольку в нем
		применяется принциа FILO). Аргументами функции служат 1,2,3 и 4,
		поэтому последовательность команд помещает в стек 4,3,2 и наконец 1.
		Эти значения соответствует переменным d, c, b и a функции. Команды,
		помещающие эти значения в стек, в приведенном ниже результате
		дизассемблирования функции main() выделены полужирным. Команды
		помещающие эти значения в стек, в приведенном ниже результате 
		дизассемблирования функции main() ...

			mov	ecx, 0x4
			mov	edx, 0x3
			mov	esi, 0x2
			mov	edi, 0x1
			call 0x1139 <test function>

		- Затем при выполнении команды call ассемблера в стек помещаются 
		адрес возврата, а выполнение передается на начало функции
		test_function() с адресом  0x1139. Адрес возврата - это
		местонахождение команды, следующей за текущей, адрес которой
		содержится в EIP, а именно значение, сохраненное на шаге 3
		обсуждавшегося цикла исполнения. В данном случае должен произойти
		возврат на адрес, где в функции main() размещаются команда leave
		
		- Команда call сохраняет в стеке адреса возврата и выполняет переход
		по содержащемуся в EIP адресу начала функции test_function(); таким 
		образом, команды пролога функции test_function() завершили создание
		кадра стека. Теперь в стек помещается текущее значение EBP. Оно
		называется сохраненным указателем кадра SFP и позволяет позже
		вернуть EBP в исходное состояние. Затем текущее значение ESP 
		копируется в EBP, чтобы установить новый указатель кадра. Этот
		указатель кадра испоьзуется для обращения к локальным переменным
		функции (flag и buffer). Память для этих переменных отводится в 
		результате вычитания из ESP.


		- С помощью GDB можно проследить, как в стеке формируется кадр.
		В следующем листинге точки останова установлены в main() перед
		обращением к test_function() и в начале test_function(). GDB
		помещает первую точку останова - после пролога функции test_function()


		- После запуска программы исполнение останавливается в точке останова
		где исследуется содержимое регистров RSP (указатель стека),
		RBP (указатель кадра) и RIP (указатель команды)
		
			list main 

				12	test_function(1, 2, 3, 4);
			
			break 12
				
				Breakpoint 1 at 0x1182: file stack_example.c, line 12

			break test_function
				
				Breakpoint 2 at 0x114d: file stack_example.c, line 2

			run

				Breakpoint 1, main () at stack_example.c:12
				
				12 test_function(1, 2, 3, 4);


			i r rsp rbp rip

				rsp 0x7fffffffe6b0 0x7fffffffe6b0
				rbp 0x7fffffffe6b0 0x7fffffffe6b0
				rip	0x555555555182 0x555555555182 <main+4>

				Breakpoint 1, main () at stack_example.c:12
				12	test_function(1, 2, 3, 4);

			
			x/5i $rip

				0x555555555182 <main+4>:	mov ecx, 0x4
				0x555555555187 <main+9>:	mov edx, 0x3
				0x55555555518c <main+14>:	mov esi, 0x2
				0x555555555191 <main+19>:	mov edi, 0x1
				0x555555555196 <main+24>:	call 0x555555555139 test_function


		- Эта точка оставнова находится как раз перед тем местом, где
		формируется кадр стека ддя вызова test_function(). 

		То есть дно этого нового кадра стека находится по адресу,
		являющемуся текущим значением RSP,
			
			# 0x7fffffffe6b0

		- Следующая точка останова расположена сразу после пролога функции
		test_function(), поэтому при продолжении работы будет построен кадр
		стека. В следующем листинге test_function() показана аналогичная
		информация для второй точки останова. Обращение к локальным переменным
		(flag и buffer) происходит относительно указателя кадра RBP

			cont
				
				Continuing.
				Breakpoint 2, test_function (a=1, b=2, c=3, d=4) at
				stack_example.c:2
			
			i r rsp, rbp, rip

				rsp 0x7fffffffe670 0x7fffffffe670
				rbp 0x7fffffffe6a0 0x7fffffffe6a0
				rip 0x55555555514d 0x55555555514d test_function+20

			disass test_function
				
				...
				mov DWORD PTR [rbp-0x24], edi
					
					# RBP указатель кадра стека и инструкция указывает на
					локальную переменную смещенную по адресу [rbp-0x24]
					относительно указателя кадра стека


				mov DWORD PTR [rbp-0x28], esi
				mov DWORD PTR [rbp-0x2c], edx
				mov DWORD PTR [rbp-0x30], ecx

			print $rbp-0x24
			
				$1 = (void *) 0x7fffffffe67c 
					
					# верх кадра стека число 1

			print $rbp-0x30	

				$2 = (void *) 0x7fffffffe670

					# низ кадра стека число 4

			x/16xw $rsp
				
				0x7fffffffe670:	0x00000004 0x00000003 0x00000002 0x00000001
				0x7fffffffe680:	0x00000000 0x00000000 0x178bfbff 0x00000000
				0x7fffffffe690:	0xffffea99 0x00007fff 0x00000064 0x00000000
				0x7fffffffe6a0:	0xffffe6b0 0x00007fff 0x5555519b 0x00005555

				

				0x7fffffffe670:	0x00000004 0x00000003 0x00000002 0x00000001
					
					# Первые четыре аргумента функции, только такой вид
					справедлив для 32 битной системы, а для 64 битной системы
					правильнее будет вывести:

					x/2xg $rsp

						0x7fffffffe670: 0x0000000300000004 0x0000000100000002
	
		- Для более корректного вывода необходимо использовать опцию g, то есть
		GIANT 8 byte (64 bits)

			x/8xg $rsp
				
				0x7fffffffe670:	0x0000000300000004	0x0000000100000002
				0x7fffffffe680:	0x0000000000000000	0x00000000178bfbff
				0x7fffffffe690:	0x00007fffffffea99	0x0000000000000064
				0x7fffffffe6a0:	0x00007fffffffe6b0	0x000055555555519b

		
		- Также в ниже в стеке содержится адрес возврата и предыдущий адрес
		на который указывал RBP до входа в функцию, это видно из раннего
		вывода содержимого регистра указателя кадра стека RBP
				
			rbp 0x7fffffffe6b0 0x7fffffffe6b0 
			 	
				# адрес в регистре до перехода в test_function
			
			disass main
				
				...
				0x0000000000001196 <+24>: call	0x1139 <test_function>
				0x000000000000119b <+29>: mov	eax, 0x0
				...

				# Адрес возврата это адрес инструкции в дизассемблированном
				коде main

			x/2xg $rsp+0x30
			
				!!!!!!!!!!!!!!!!

				0x7fffffffe6a0:	0x00007fffffffe6b0	0x000055555555519b
			
				!!!!!!!!!!!!!!!! Успешно найдено


		- Остальная память отведена для локальных переменных flag и buffer[10]
		их тоже можно обнаружить. Возможно они могут находится по данным
		адресам: 0x7fffffffe680

			x/2xg $rsp+0x10

				0x7fffffffe680:	0x0000000000000000	0x00000000178bfbff
					
					# но сейчас здесь лежит какой-то мусор, а конкретнее...

			x/dw  $rsp+0x10+0x8 
				
				0x7fffffffe688:	395049983 
					
					# рандомное число, но это потому, что инструкции еще
					не были выполнены

			nexti
			nexti
			nexti
				
				6 flag = 31337 

			x/2i $rip

				mov    DWORD PTR [rbp-0x18],0x7a69
				mov    BYTE PTR [rbp-0x12],0x41 

				# Кажется здесь проясняется картина

			nexti 
				
				7	buffer[0] = 'A'

			x/2xg $rsp+0x10
				
				0x7fffffffe680:	0x0000000000000000	0x0000000000007a69

			x/dw #rsp+0x10+0x8
				
				0x7fffffffe688:	31337 

				# ну вот и заветное число, присвоеное в листинге функции
				на второй строчке кода, теперь осталось найти букву 'A'

			nexti
			x/2xg $rsp+0x10
				
				0x7fffffffe680:	0x0000000000000000	0x0041000000007a69

			x/xg $rsp+0x10+0x8
				
				0x7fffffffe688:	0x0041000000007a69

			x/8xb $rsp+0x10+0x8

				0x7fffffffe688:	0x69 0x7a 0x00 0x00 0x00 0x00 0x41 0x00

			x/cb $rsp+0x10+0x8+0x6
	
				!!!!!!!!!!!!

				0x7fffffffe68e:	65 'A'

				!!!!!!!!!!!! Успешно найдено

		
		- По завершении выполнения весь кадр выталкивается из стека, а в RIP
		помещается адрес возврата, чтобы программа могла продолжать свое
		выполнение. Если внутри функции происходит вызов другой функции,
		в стек проталкивается еще один кадр, и так далее. В конце работы
		каждой функции ее кадр стека выталкивается, чтобы можно было
		продолжить выполнение предыдущей функции. Такой режим работы
		оправдывает организацию этого сегмента памяти в виде структуры данных
		типа FILO 

		- Различные сегменты памяти организованы в указанном порядке - от 
		младших адресов памяти к старшим. Так как нумерованный список
		привычнее читать сверху вниз, младшие адреса памяти располагаются
		вверху. В некоторых книгах принят протиположный порядок, что может
		сбивать с толку, поэтому в данной книге меньшие адреса памяти всегда
		оказывается вверху. В большинстве отладчиков память также
		отображается в этом стиле: младшие адреса паямяти находятся вверху,
		а старшие - внизу

		- Поскольку размер кучи и стека устанавливается динамически, эти два
		сегмента растут в противополжных направлениях навстречу друг другу.
		Это сокращает непроизвольный расход памяти, позволяя увеличить стек,
		когда куча невелика и наоборот

			Младшие адреса:
			
			Сегменты 

				TEXT
				DATA
				BSS

			Сегмент HEAP - куча растет в направлении старших адресов

					младшие <<<стек<<------->>куча>>> старшие

				растет в направлении младших адресов - Сегмент STACK


			
0x271 


### Сегменты памяти в C 

	
		- В C и других компилируемых языках скомпилированный код помещается
		в сегмент текста, а переменные располагаются в других сегментах.
		Сегмент, в который попадает переменная, зависит от того, как она
		определена:
			
			# Переменные, определенные вне каких-либо функций, считаются
			глобальными

			# Если статическая или глобальная переменная описана с начальным
			значением, она помещается в сегмент DATA, в противном случае
			в сегмент BSS

		
		- Память в сегменте кучи нужно сначала выделить с помощью функции
		malloc(). Обычно обращение к памяти в куче происходит через указатели
		Остальные переменные функции хранятся в сегменте стека. В стеке может
		быть много кадров, поэтому помещаемые в стек переменные могут
		сохранять свою уникальность в различных функциональных контекстах
		Программа memory_segments.c поможет разобраться с этими концепциями
		в С 

			




























			


			


		













































			
































































































































				

				






















































































































































			



					


















































































			































































			

			















			









			














































































	












