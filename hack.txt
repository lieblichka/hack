Хакинг искусство эксплоита 2-е 

0x220

- Язык ассемблера # Intel X86, Sparc, ARM

- Языки высокого уровня # С, C++, FORTRAN

- Псевдокод # естественный язык, похож на язык высокого уровня 


0x231

- if-then-else # управляющие операторы
  
  	if (условие) then	{набор инструкций}
	
	else 				{набор инструкций}


0x232

- while/until # циклы 

	while пока (истина) {набор инструкций}

	until пока не (!истина) {набор инструкций}


0x240

- for # цикл со счетчиком

	for (i = 0; i < 5; i++) {набор инструкций}

0x241

- Переменные
	
	int a = 13, b;
	float k;
	char z = 'A';

	k = 3.14;
	z = 'w';
	b = a + 5;


0x242

- b = a + 7 # арифмитические операторы

	 b = a + 5 # Сложение 
	 b = a - 5 # Вычитание
	 b = a * 5 # Умножение
	 b = a / 5 # Деление
	 b = a % 5 # Деление по модулю
	 

- Сокращенная запись:

	i = i + 1 | i++ or ++i # прибавить 1 к переменной

	i = i - 1 | i-- or --i # вычесть 1 к переменной

	-----
	a = 5;
	b = a++ * 6 # a = 6, b = 30 т.к постфиксный инкремент
	b = ++a * 6 # a = 6, b = 36 т.к префиксный инкремент

	-----
	i = i + 12 | i += 12 # Прибавить к переменной значение
	i = i - 12 | i -= 12 # Вычесть из переменной значение
	i = i * 12 | i *= 12 # Умножить переменную на значение
	i = i / 12 | i /= 12 # Разделить переменную на значение 
	

- Логические операторы (Операторы сравнения)

	< | (a < b) # Меньше
	> | (a > b) # больше
	
	<= | (a <= b) # Меньше или равно
	>= | (a >= b) # Больше или равно
	== | (a == b) # Равно
	!= | (a != b) # Не равно
	
	!(a < b) равносильно (a >= b)

- Операторы сравнения ИЛИ / И

	|| / ((a < b) || (a < c)) # ИЛИ 

	&& / ((a < b) && (a < c)) # И 


0x250 ### ПРАКТИЧЕСКАЯ РАБОТА ###

БИБЛИОТЕКИ 

	- stdio  # /usr/include/stdio.h 
	стандартная библиотека ввода вывода в которой опеределенны
	некоторые константы и прототипы функций 

КОМПИЛЯТОР

	- GNU Compiler Collection (GCC)
	
		@ gcc firstprog.gcc # код на языке C 
		@ ls -l a.out # скомпилированная программа
		@ ./a.out # выполнить программу

ДВОИЧНЫЙ ИСПОЛНЯЕМЫЙ ФАЙЛ a.out 

	- objdump # программа для изучения скомпилированных файлов
		
		@objdump -D a.out | grep -A20 main 
			# такой вид команды будет выводить лишь 
			# следующие 20 строк после регулярного main
		
	- байты представленны в 16-ричной смстеме счмсления 
			# 0 1 2 3 4 5 6 7 8 9 A B C D E F
			# 1 byte = 8 bit 256(2^8) возможных значений
		
	- 16-ричн числа слева это адреса памяти 0x8048374
			# Биты команд машинного языка размещаются
			# в байтах памяти для временного хранения
	
	- Разрядность процессора
			# в 32-разрядн 2^32 = 4 294 967 296 адресов
			# в 64-разрядн 2^64 = 1.8446741 * 10^19 адресов
	
	- Язык ассемблера
			# На нем команды записанные справа составляют
			# набор мнемоник для соотв. машинных команд	
			- Команда ret # она же 0xc3 or 11000011
	
	- Синтаксисы Ассемблера AT&T & Intel
		# AT&T характеризуется символами % и $
		# Intel более понятный для анализа

	- @objdump -M intel -D a.out
		# Для установления пользовательского синтаксиса
		# используется опция -M с аргументом intel

	- Регистры процессора
		# Набор специальных переменных, большинство
		# инструкций пользуется этими регистрами 
		# для чтения или записи данных	


0x252 #### Процессор x86

	- GDB # отладчик для выполнения скомпилированных и
	исследования памяти программы и просматривания регистров 

		@gdb -q ./a.out # Запуск отладки программы

		(gdb) break main # точка останова перед функцией main()

		(gdb) run # запуск отладки

		(gdb) info registers # вывести содержимое регистров
	
		(gdb) quit # закрыть gdb


	- Регистры общего назначения

		RAX # Accumulator - аккумулятор

		RCX # Counter - счетчик

		RDX # Data - регистр данных

		RBX # Base - базовый регистр


	- Указатели (индексные регистры) регистры общего назначения

		RSP # Stack Pointer - указатель стека

		RBP # Base Pointer - указатель базы

		RSI # Source Index - индекс источника

		RDI # Destination Index - индекс приемника 

		# Первые два регистра хранят 32-х разрядные адреса,
		  указываюзие местоположение в памяти. Эти регистры 
		  весьма важны для выполнения программ и управления
		  памятью

		# Последние два регистра формально тоже являются 
		  указателями обычно указывающие на источник и приемник
		  когда нужно прочитать или записать данные
		
	- Регистр EIP
		
		# Instruction Pointer - указатель команды, содержит адрес
		следующей команды для процессора, данный регистр очень важен
		и активно используется при отладке

	- Регистр EFLAGS (флагов)
		
		# содержит несколько битовых флагов, участвующих в операциях
		  сравнения и сегментации памяти


0x253 Язык ассемблера PAGE 36 

	- Внутри GDB синтаксис дизассемблирования Intel можно задать
	командой 
		@ set disassembly intel | set dis intel

	- Чтобы такая настройка действовала при каждом запуске GDB
	необходимо поместить команду "set dis intel" в файл .gdbinit
	расположенный в домащнем каталоге
		@ echo "set disassembly-flavor intel > ~/.gdbinit"

	- Команды ассемблера в синтаксисе Intel обычно имеют такой вид:
		# операция <приемник>, <источник>
		Значениями приемника и источника могут быть Регистры,
		Адрес памяти или Значение

	- Операции представляют собой интуитивные мнемоники
		
		MOV # перемещает(MOVE) значение источника в приемник

		SUB # вычитает(SUBSTRUCT) значение источника в приемник

		INC # увеличивает(INCREMENT) значение источника в приемник

	----
	
	89 e5		mov rbp, rsp # Перемещение значения из RSP в RBP

	83 ec 08	sub rsp, 0x8 # Вычесть 8 из RSP и сохранить результат в RSP
	

	- Операции управляющие потоком выполнения
		
		CMP # операция для сравнения значений 

		# а операции начинающиеся с J (jump) осуществляет переход
		в другое место кода (в зависимости от результатов сравнения)

		JLE # jump if less than or equal to - перейти если меньше
		или равно
		

		JMP # операция безусловного перехода 
	
	----

	83 7d fc 09		cmp DWORD PTR [rbp-4], 0x9
		
		# 4 байтовое значение (DWORD), находящееся в RBP, уменьшенное
		на 4, сравнивается с 9

	7e 02			jle 8048393 <main+0x1f>
		
		# Данная команда (перейти если меньше или равно) связана с
		результатом предыдущего сравнения

		-> если указанное 4-байтовое значение меньше или равно 9
		осуществляется переход к команде по адресу 0x8048393

	eb 13			jmp 80483a6 <main+0x32>

		# Данная команда (перейти по адресу) свзяна с двумя предыдущими
		командами логическое структурой

		-> если указанное 4-байтовое значение больше 9 осуществляется
		переход к команде по адресу 0x80483a6

	
	- Компилятор GCC можно запустить с флагом -g, чтобы включить в
	программу дополнительную отладочную информацию, с помощью которой
	GDB получит доступ к исходному коду

		@ gcc -g firstprog.c  # внести доп-информацию в исполняемый файл

		@ ls -l a.out # размер исполняемого файла изменится

		@ gdb -q a.out # запуск gdb

		gdb@ list # вывести исходный код на C (доп информация)

		gdb@ disassemble main # вывести результат дизассемблирования main

		gdb@ break main # точка останова main

		gdb@ run

	
	- info register rip | i r eip 
		
		# значение rip (указатель текущей команды)

	
	- В отладчике GDB можно непосредственно изучать содерджимое 
	с помощью команды x (examine), позволяющая просмотреть разными
	способами содержимое по определенному адресу памяти 
		
		x # examine
		rip = 0x8048384

		o # Восьмеричный (octal)
			
			x/o 0x8048384 (rip address) =>	077042707
			x/o $rip    (equal prev) 	=>	077042707

		x # Шестнадцатеричный (hexadecimal)
			
			x/x $rip => 0x00fc45c7

		u # Десятичный без знака (unsigned decimal)
			
			x/u $rip => 16532935

		t # Двоичный (binary)
			
			x/t $rip => 00000000111111000100010111000111

		# Все числа на выходе эквивалентны друг другу только
		в разных системах счисления

	
	- В команде examine можно также указать число перед форматом, чтобы
	исследовать несколько блоков по целевому адресу
		
		x/2x $rip: 0x00fc45c7 0x83000000

		x/12x $rip: 0x00fc45c7 0x83000000 0x7e09fc7d 0xc713eb02
					0x84842404 0x01e80804 0x8dffffff 0x00fffc45
					0xc3c9e5eb 0x90909090 0x90909090 0x5de58955

	- По умолчанию размер одного блока равен четырем байтам, что
	составляет одно компьютерное слово. Размер отображаемых блоков
	можно изменить, добавив к имени формата букву, соответствующую размеру

		b 1 (byte), байт

			x/8xb $rip:

					0xc7 0x45 0xfc 0x00 0x00 0x00 0x00 0x83

		h Полуслово (halfword), 2 байта

			x/8xh $rip

					0x45c7 0x00fc 0x0000 0x8300 
					0xfc7d 0x7e09 0xeb02 0xc713
			
		w Слово (word), 4 байта 

			x/8xw $rip
					
					0x00fc45c7 0x83000000 0x7e09fc7d 0xc713eb02
					0x84842404 0x01e80804 0x8dffffff 0x00fffc45


		g Гигантское слово (giant), 8 байтов

			x/xg $rip
					
					0x83000000000000fc45c7
	 
	
	- Это может вызвать некоторую путаницу, поскольку иногда термином
	слово обозначают двухбайтные значения. В таких случаях двойным
	или DWORD, называют четырехбайтные значения. В данных примерах слово

		# DWORD относится к 4 байтным значениям.

		# (short) относятся к коротким словам или полусловом
	
	
	- Особенности расположения памяти
		
		Первая команда examine показывает, что первые два байта содержат
			
			0xc7 и 0x45

		Тогда как полуслово, расположенное по тому же адресу содержит

			0x45c7 # байты в обратном порядке

		Такой же эффект наблюдается в полном четырехбайтном слове
			
			0x00fc45c7
		
		Хотя по одному первые четыре байта выводятся в порядке

			0xc7 0x45 0xfc 0x00

	- Процессоры с префиксом x86 хранит значение байтов в обратном
	порядке (little-endian byte order)

		# Если четыре байта нужно интерпретировать как одно число, байты
		следует считывать в обратном порядке. Возможной путаницы можно
		избежать, отображая числа как шестнадцатеричные или как десятичные
		без знака

		x/4xb $rip
			
			0xc7 0x45 0xfc 0x00

		x/4ub $rip

			199 69 252 0
			

			# Если использовать неправильный порядок байтов, то получается
			неверный результат

			199 * (256^3) + 69 * (256^2) + 252 * (256^1) + 0 * (256^0)
			= 3343252480
			
			# Если использовать правильный порядок байтов, то получается
			верный результат

			0 * (256^3) + 252 * (256^2) + 69 * (256^1) + 199 * (256^0)
			= 16532935

		x/1xw $rip

			0x00fc45c7

		x/1uw $rip
			
			16532935


	- Команде examine можно также передать параметр формата 
	i (instruction), чтобы вывести содержимое памяти в виде команд
	ассемблера
		
		for (i = 0; i < 10; i++)
		
		x/i $rip # Вывести инструкцию по адресу регистра 
			 
			 mov DWORD[rbp-0x4],0x0
		
		x/3i $rip # Вывести следующие три инструкции по адресу регистра
			
			 mov DWORD PTR[rbp-0x4],0x0
			 cmp DWORD PTR[rbp-0x4],0x9
			 jle 0x8048393 <main+31>
		
		x/7xb $rip # 
			
			0x555555555141: 0xc7 0x45 0xfc 0x00 0x00 0x00 0x00

	- Предшествующие результаты работы OBJDUMP подтверждают, то семь
	байтов на которые указывает регистр RIP, действительно являются 
	машинным кодом соответствующих команд ассемблера
			
		1141: c7 45 fc 00 00 00 00 mov DWORD PTR [rbp-0x4], 0x0

		# Эта команда ассемблера поместит значение 0 в ячейку памяти,
		адрес которой на 4 меньше того, что содержится в регистре RIP.
		Это адрес, по которому хранится переменная i кода C;

		# i была объявлена как целое число, использующее 4 байта памяти
		в архитектуре x86. По существу, данная команда обнулит переменную
		i для цикла for

		# Если посмотреть сейчас содержимое пямяти по этому адресу, там
		обнаружится случайный мусор
	
	- Отобразить содержимое пямяти можно разными способами. Все приведенные
	ниже способы отображают 4 байта мусора в том месте памяти, которое будет
	очищено в результате выполнения текущей команды 

		i r rbp | i r $rbp 
			
			rbp 0x7fffffffe700 0x7fffffffe700

		x/4xb $rbp - 4 # содержимое в первых четырех байтах в $rbp - 4 
			
			0x7fffffffe6fc: 0x55 0x55 0x00 0x00
	
		print $rbp - 4
			
			# вывести и сохранить во временную переменную
			к какому адресу принадлежит $rbp - 4

			$1 = (void *) 0x7fffffffe6fc

		x/4xb $1 # вывести содержимое по адресу во временной переменной
			
			0x7fffffffe6fc: 0x55 0x55 0x00 0x00
		
		x/xw $1 # вывести 4-х байтовое значение по адресу в $1
			
			0x7fffffffe6fc: 0x00005555
			
	- Выполнить текущую команду можно с помощью команды отладчика
	nexti (next instuction). Процессор прочтет команду по адресу,
	находящемуся в EIP, выполнит ее и переведет EIP на следующую
	команду

		nexti # выполнить текущую инструкцию и переместить EIP
				к следующей инструкции
		
			for (i = 0; i < 10; i++)

			0x555555555148:	7 0x8d4813eb

		x/xw $1 # предыдущая инструкция изменила значение в регистре
				[rbp-0x4] (integer i) на 0 => int i = 0
			
			0x7fffffffe6fc: 0x00000000

		x/dw $1 # вывести целочисленное значение 4-х байтного регистра
			
			0 # int i = 0

		i r $rip # вывести адрес на который указывает регистр rip

			rip 0x555555555148 0x555555555148 <main+15>

		x/i $rip # вывести текущую инструкцию на которую указывает rip
			
			0x555555555148 <main+15>: jmp 0x55555555515d <main+36>
		
	- Как и ожидалось, предыдущая команда обнулила 4 байта по адресу
	EBP - 4, представляющего собой память, отведенную для переменной i
	После этого EIP	перешел к следующей команде.

		
	
	- JMP 0x55555555515d <main+36>
			
		JMP команда безусловного перехода перенаправит на следующую
		инструкцию сравнения cmp DWORD PTR [rbx-0x4],0x9
	
	- nexti
		
		for (i = 0; i < 10; i++)

	- x/i $rip

		0x000055555555515d: <main+36> cmp DWORD PTR [rbp-0x4],0x9
			
		# Команда cmp (compare) выполняет сравнение, в данном случае
		содержимого памяти, отведенной для переменной i языка С, со
		значением 9.

	- Следующая команда JLE выполняет переход при условии 
	<меньше или равно> 

		nexti
		x/i $rip 
			
			0x555555555161 <main+40>: jle 0x55555555514a <main+17>

	- При этом проверяется результат предыдущей команды сравнения
	хранящийся в регистре EFLAGS, и если он совпадает с <меньше или равно>
	то EIP перенацеливается на совсем другой участок кода.

	- В данном случае инструкция говорит, что нужно перейти по адресу
		
		if <= jump to 0x55555555514a <main+17>
		
		0x55555555514a <main+17>: lea rax,[rip+0xeb3] # 0x555555556004
		0x555555556004: rex.W

	- Если значение будет больше, то EIP укажет на следующую команду
		
		mov eax,0x0
		leave
		ret

	- Совокупность всех инструкций составляет конструкцию if-then-else
	
	
	- LEA приемник, источник (Load Effective Address)
		
		ИСТОЧНИКОМ может быть только переменная (ячейка памяти),
		а ПРИЕМНИКОМ - только регистр (но не сегментный)
		
		Если адрес 32 разрядный, а ПРИЕМНИК 16 разрядный, то старшая
		половина вычисленного адреса теряется. Если наоборот ПРИЕМНИК
		32 разрядный, а адрес 16 разрядный, то вычисленное смещение
		дополняется нулями 

	- LEA rax, [rip+0xeb3] # 
	
		
		rip + 0xeb3 == 
		0x55555555514a + 0xeb3 ==
		0x55555555514a + 0x000000000eb3 = 0x555555555ffd

	- Чтобы проверить, что именно содержится по адресу 0x55555555ffd
	используем examine and print

		print $rip+0xeb3
			
			$1 = (void *)0x555555555ffd

		x/8xb $1 # Вывести 8 байтов по сохраненному адресу

			0x00 0x00 0x00 0x01 0x00 0x02 0x00 0x48
			
			# В выводе вроде бы ничего необычного, но на самом деле
			можно заметить в последнем байте 0x48, что соответствует 
			символу 'H' по таблице ASCII. Выведем еще 8 байтов после 

		x/16xb $1 

			0x00 0x00 0x00 0x01 0x00 0x02 0x00 0x48
			0x65 0x6c 0x6c 0x6f 0x20 0x57 0x6f 0x72
			
			# Здесь уже проясняется явная картина слова 'Hello '
			
			0x48 = 'H'
			0x65 = 'e'
			0x6c = 'l'
			0x6c = 'l'
			0x6f = 'o'
			0x20 = ' '
		

	- К счастью, команда GDB examine позволяет отображать и такое
	содержимое памяти. Формат c автоматически покажет байты согласно
	таблице ASCII, а формат s покажет всю строку символьных данных
			
		nexti # выполнить текущую инструкцию и перейт к следующей
		
			# Как помнится текущая инструкция lea rax, [rip+0xeb3]
			помещает данные из адреса 0x555555555ffd, но только
			используя эффективный адрес
			
	- Если глянуть по адресу rax, можно обнаружить интересный порядок
	байтов 
		
		x/8xb $rax # Вывести 8 байтов по адресу регистра rax
			
			0x48 0x65 0x6c 0x6c 0x6f 0x20 0x57 0x6f
			
			# Очень похоже на содержимое rix+0xeb3 (0x555555555ffd)

			x/16xb $1 # (0x555555555ffd)

				0x00 0x00 0x00 0x01 0x00 0x02 0x00 0x48
				0x65 0x6c 0x6c 0x6f 0x20 0x57 0x6f 0x72

	- Теперь наконец можно увидеть долгожданное сообщение 
	в регистре $rax
		
		x/14cb $rax
			
			0x555555556004:
			72 'H' 101 'e' 108 'l' 108 'l' 111 'o' 32 ' ' 87 'W' 111 'o'
			0x55555555600c:
			114 'r' 108 'l' 100 'd' 33 '!' 32 ' ' 0 '\000'

		x/s $rax
			
			0x555555556004: "Hello World! "
	
	- Подготовка для вызова функции printf(),
		
		mov rdi, rax # поместить содержимое rax в rdi
			
			# Скорее всего следующая инструкция работает с данным
			регистром для вывода,

		x/4xw $rdi  # при попытке проверить содержимое данного регистра
			
			0x1: Cannot access memory at address 0x1 
			
			# Нет доступа к памяти 

	- Эта строка передается в качестве аргумента функции printf(), а
	следующая инструкция является вызовом функции printf()
			
		x/i $rip
			
			call 0x555555555030 <puts@plt>
				
			# Вместо вызова printf вызываетя функция puts, это обусловленно
			тем, что процессор знает, для printf будет затраченно больше
			времени, а строка переданная в printf не содержит доп аргументов
			и для тривиальных строк ему проще вызвать функцию puts@plt 
		
		nexti 
			
			Hello World!
	
	- Для осуществления итерации переменной i, находящейся по адресу
	$rbp - 4 в текущем исполняемом файле используется ADD

		add DWORD PTR [rbp-0x4], 0x1 # операция сложения 
	
		x/d $rbp - 4 # проверить значение переменной i
			
			0x7fffffffe6fc: 0

		nexti # add DWORD PTR [rbp-0x4], 0x1 ... прибавить 1 

		x/dw $rbp - 4  
		
			0x7fffffffe6fc: 1 # значение изменилось !!!
	
	- После всех действий повторно производится сравнение 
		
		cmp DWORD PTR [rbp-0x4], 0x9 
			# если результатом является <= [CF AF SF IF]
			перенос настройка знак прерывание
	
	- Если результат в eflags <=
		
		jle 0x55555555514a <main+17> # возврат в начало цикла

	  
			
0x261 Строки 

	
	- Значение "Hello World! \n", передаваемое функции printf
	в предыдущей программе, является строкой формально, массивом
	символов. Массив в C это просто список из n элементов определенного
	типа. Массив из 20 символов это 20 символов, размещенных в памяти
	один за другим. Массивы также называют буферами. Программа
	char_array.c содержит пример массива символов. 
	
		char str_a[20];
	
	-Компилятор GCC принимает ключ -o, с помощью которого можно задать
	имя выходного файла, содержащего результат компиляции. Ниже показано,
	как скомпилировать эту программу в исполняемый двоичный файд char_array.

		gcc -o char_array char_array.c 
			
			ls -l char_array

		./char_array
			
			Hello World!

	- В данной программе определен массив str_a из 20 символов, и во все
	элементы этого массива поочередно выполняется запись. Нумерация
	элементов начинается с 0, а не с 1. Кроме того, последним символом
	является 0 (null, или нулевой байт)
		
		0 | '\0'
	
	- Поскольку массив определен как символьный, ему было выделено 20 байт
	памяти, но фактически из них использовано только 12. Нулевой байт в конце
	играет роль разделителя, сообщая функциям, сообщая функциям, работающим
	с этой строкой, что в этом месте необходимо остановиться

	
	- Задавать каждый символ в массиве утомительно, а строки используются
	достаточно часто, поэтому для обработки строк был создан набор
	стандартных функций. Например функция strcpy() копирует строку из
	ИСТОЧНИКА в ПРИЕМНИК, последовательно просматривая строку источник
	и копируя каждый байт в СТРОКУ-ПРИЕМНИК (останавливаясь при
	обнаружении нулевого байта - конца строки  0 | '\0')

		char strcpy(char *dst, const char *src); # прототип strcpy
		
		*dst # destionation = ПРИЕМНИК адрес назначения 
		*src # source = ИСТОЧНИК

	- Программу char_array.c можно переписать с использованием функции
	strccpy(), так что она будет выполнять ту же задачу с применением 
	библиотеки строковых фукнций. В следующей версии программы char_array
	включается заголовочный файл STRING.H, поскольку в ней используется 
	строковая функция 

		char_array2.c 
		
		#include <stdio.h>	# printf()
		#include <string.h> # strcpy()


	
	- Изучим эту программу с помощью GDB. В приведенном ниже листинге
	скомпилированная программа открывается в отладчике, и устанавливаются
	точки останова до функции STRCPY(), на ней и после нее, что отмечено
	полужирным. Отладчик остановит выполнение программы в каждой из этих
	точек, что позволит просмотреть содержимое регистров и памяти. 
	
	- Код функции STRCPY() берется из библиотеки общего доступа, поэтому 
	задать точку останова внутри этой функции можно только после начала 
	выполнения программы

		gcc -g -o char_array2 char_array2.c # компиляция с доп инф.
		
		gdb -q ./char_array2 # отладка

			break 6 # Установить точку останова на 6 строке
			
				Breakpoint 1 at 0x80483c4: file char_array2.c line 6

			break strcpy # line 7 # установить точку останова на функции

				Function "strcpy" not defined.
				Make breakpoint pending on future shared library load? y
				Breakpoint 2 (strcpy) pending.

			break 8 
				
				Breakpoint 3 at 0x80483d7: file char_array2.c, line 8

	- При запуске программы обрабатывается точка останова STRCPY()
	В каждой точке останова рассмотрим содержимое RIP и команды, на
	которое он указывает. Обратите внимание

		run # выполнить до первого брекпоинта

			Staring program
			Breakpoint 4 at 0xb7f076f4 
			Pending breakpoint "strcpy" resolved

			Breakpoint 1, main () at char_array2.c:7
			7 strcpy(str_a, "Hello World!\n");

		i r $rip 
			
			rip 0x80483c4 0x80483c4 
	
		
		continue # перейти к следующему брекпоинту	
	
			Continuing
			Breakpoint 4, 0xb7f076f4 in strcpy () 
			from /lib/tls/i686/cmov/libc.so.6

		i r $rip 
			
			rip 0xb7f076f4 0xb7f076f4  <strcpy>

		continue
			
			Continuing
			Breakpoint 3, main () at char_array2.c:8
			8 printf(str_a)

		i r $rip 
			
			rip 0x80483d7 0x80483d7 


		x/5i $rip

	- Адрес, находящийся в EIP в средней точке останова, отличается
	от лругих, потому-что код функции strcpy() находится в загруженной
	библиотеке. В средней точке отладчик отображает EIP для кода функции
	strcpy(), тогда как в двух других точках EIP указывает на код функции
	main(). Хочу подчеркнуть, что EIP способен "переноситься" из основного
	кода в код strcpy() и обратно. При каждом вызове функции запись об этом
	сохраняется в структуре данных, называемой стеком. С помощью стека RIP
	может возвращаться из длинных цепочек вызовов функций.

	- В GDB есть функция есть команда bt (от backtrace) позволяющая
	проследить цепочку вызовов, помещенную в стек. Ниже показано состояние
	стека для каждой точки останова 


		run
			
			Breakpoint 1, main () at char_array2.c: 7
			7 strcpy(str_a, "Hello, World!\n");

		bt 
			
			#0 main () at char_array2.c:7

		cont # continue
			
			Continuing
			Breakpoint 4, 0xb7f076f4 in strcpy() from ...

		bt  # проверить стек вызовов функций
			
			#0 0xb7f076f4 in strcpy() from /usr/lib/libc.so.6
			#1 0x080483d7 in main() from char_array2.c:7

		cont 
			
			Breakpoint 3, main () at char_array2.c:8
			8 printf(str_a);

		bt
			
			#0 main () at char_array2.c:8


	- В средней точке останова обратная трассировка стека показывает
	вызов strcpy() немного изменился. Это результат действия защиты от
	эксплойтов, включаемой по умолчанию в ядро Linux начиная с версии 
	2.6.11. Несколько позднее мы подробно рассмотрим эту защиту



0x262 

### Целые числа со знаком, без знака, длинные и короткие ### 


	- По умолчанию числовые значения в C имеют знак, то есть могут быть
	как положительные так и отрицательными. Напротив, беззнаковые значения
	не могут быть отрицательными. Поскольку все это хранится, все числовые
	значения должны хранится в двоичном виде и двоичный вид беззнаковых
	значений понятнее всего.

	- 32 разрядное беззнаковое целое может принимать значения от 
		
		0 (все рарзряды нули)
			до
		4 294 967 295 (все разряды единицы)

	- 32 разрядное целое со знаком содержит те же 32 бита и, следовательно
	может быть одной из 2^32 возможных комбинаций.
		

		- 2 147 483 648 
			до
		2 147 483 647 

	
	- Положительные значения со знаком имеют тот же вид, что и беззнаковые,
	но отрицательные хранятся иначе - в так называемом дополнительном коде

	- Представление чисел в ДОПОЛНИТЕЛЬНОМ КОДЕ  удобно для работы двоичных
	сумматоров: если сложить отрицательную величину в дополнительном коде
	с положительным числом с такой же абсолютной величиной, то в результате
	получится 0. 



	- Чтобы получить запись в двоичном дополнительном коде, нужно записать
	число в двоичном виде, инвертировать все его разряды и прибавить к
	результату 1. Звучит странно, но действительно позволяет складывать
	отрицателные числа с положительными с помощью простых двоичных
	сумматоров

	- Эту арифметику легко проверить с помощью python.
	
		# Сначала мы видим, что двоичное значение 01001001
		это положительное число 73

		a = 0b0100100
		print(a)
			73 # a in decimal 
		---------------------
		
		
		# Затем инвертируем все разряды 
		
		a_reverse = 0b10110110
		print(a_reverse)
			182 # a reverse in decimal
		------------------------------


		# Прибавляем 1, чтобы получить дополнительный код для
		-73 (10110110)

		dop_code = a_reverse + 1 	
			183 # dop_code in decimal
		-----------------------------

		
		# Сложив эти две величины, получим 0 в исходных 8 разрядах
		Вывод python показывает 256, потому что не знает, что мы оперируем
		всего лишь с 8-битными числами. В двоичном сумматоре этот бит
		переноса будет отброшен, поскольку выходит за границы памяти,
		отведенной переменной.

		bin(a + dop_code) # 1[00000000]
			
			'0b100000000' # 256
		
		
		- В C можно определить переменную как беззнаковую с помощью
		ключевого слова UNSIGNED, помещаемого в объявлении перед
		именем переменной. Беззнаковое целое объявляется как UNSIGNED INT
		
		- Кроме того,  размер памяти, выделяемой числовой переменной
		можно увеличить или уменьшить с помощью ключевых слов LONG и SHORT
		Фактический размер зависит от архитектуры, для которой компилируется
		код.

		- В языке C есть оператор SIZEOF(), умеющий определять размер 
		некоторых типов данных. Он действует как функция, принимающая на 
		входе тип данных и возвращаюшая размер в целевой архитектуре
		переменной, объявляемой с таким типом.

		- Следующая программа datatype_sizes.c исследует размер данных
		с помощью функции sizeof()

			gcc datatype_sizes.c -o datatype_sizes
		
		
		- В коде программы datatype_sizes.c функция printf() исползуется
		используется несколько по-иному, чем прежде. Здесь применен так
		называемый спецификатор формата, чтобы показать значения,
		возвращаемые вызовами sizeof()


		- Как уже отмечалось, в архитектуре x86 знаковые и беззнаковые 
		целые числа занимают 4 байта. Число с плавающей точкой тоже
		занимает 4 байта, а символьному типу нужен всего 1 байт. Ключевые
		слова LONG and SHORT можно использовать и с переменными с плавающей
		точкой (DOUBLE/LONGD DOUBLE), чтобы увеличить или сократить размер.



0x263

### УКАЗАТЕЛИ ###


		
		- Регистр RIP представляет собой указатель следующей команды,
		поскольку содержит ее адрес. Идея указателей используется и в языке
		C. Поскольку физическую память реально перемещать нельзя, приходится
		копировать содержащуюся в ней информацию. Копирование больших
		блоков памяти, чтобы с ними могли работать разные функции и в 
		разных местах, требует очень больших накладных расходов. Это
		дорого обходится и с точки зрения памяти, потому что перед
		копированием нужно сохранить или выделить память для нового
		экземпляра данных. Решение данной проблемы дают указатели. Гораздо
		проще не копировать большой участок памяти, а передать адрес его
		начала

		- Указатели объявляются и используются в C так же, как переменные
		прочих типов. В архитектуре x86 применяется 32-разрядная адресация,
		поэтому указатели имеют размер 32 бита (4 байта), а в x86_64 64 бита
		(8 байтов). Указатели объявляются с помощью звездочки (*),
		помещаемой перед именем переменной. В результате указатель
		оказывается не переменной некоторого типа, а средством указания на
		данные этого типа. Программа pointer.c демонстрирует применение
		укзателей с типом данных char, имеющих размер 1 байт


			gcc -o pointer pointer.c

		
		- Как сказано в комментариях, первый указатель устанавливается на
		начало массива символов. Такая сссылка на массив фактически
		преставляет собой указатель. Выше этот буфер передавался функциям
		PRINTF() and STRCPY() именно как указатель. Второму указателю
		присваивается адрес из первого плюс 2, а затем выполняется печать 
		некоторых данных 
			
			./pointer

				Hello, World!
				llo, world!
				Hey you guys!

		
		- Посмотрим эту программу с помощью GDB. Программа компилируется,
		и задается точка останова на 12 строке исходного кода. В результате
		останова произойдет после того, как строка "Hello World!\n" будет
		скопирована в буфер str_a


			gdb -q ./pointer # отладка pointerz


			break 12
				
				Breakpoint 1 at 0x1186: file pointer.c, line 12

			run # go run to breakpoint at line 12

				Breakpoint 1, main () at pointer.c:12
				12	printf(pointer);

			x/xw pointer # посмотреть содержимое по адресу в указателе
				
				0x7fffffffe6c0: 0x6c6c6548

			x/s pointer # вывести строку по адресу в указателе 
				
				0x7fffffffe6c0: "Hello World!\n"


		- Если рассмотреть указатель как строку, то заметно, что это наша
		строка, находяшаяся по адресу 0x7fffffffe6c0. Не забываем, что в
		переменной-указателе хранится не сама строка, а только ее адрес



		- Чтобы увидеть фактические данные хранящиеся в переменной указателе
		нужно воспользоваться оператором адреса. Оператор адреса является
		унарным, то есть применяется к единственному аргументу. Он
		представяет собой всего лишь амперсанд (&), помешаемый перед
		именем переменной. При его использовании возвращается адрес этой
		переменной, а не ее значение. Этот оператор есть и в GDB, и в языке С
		
			x/xg &pointer # вывести адрес самого указателя и адрес на
							который он указывает
				
				0x7fffffffe6b0: 0x00007fffffffe6c0
				
				- Мы видим, что переменная pointer находится в памяти по
				адресу 0x7fffffffe6b0 и хранит адрес 0x7fffffffe6c0


			print &pointer
				
				$1 = (char**) 0x7fffffffe6b0

			print pointer

				$2 = 0x7fffffffe6c0 "Hello World!\n"

		
		- Оператор адреса часто используется вместе с укзаталями, поскольку
		указатели хранят адреса памяти. Программа ADDRESSOF.C демонстрирует,
		как адрес целочисленной переменной помещается в указатель.
		Соответствующая строка кода выделена полужирным.
		
			gcc -g -o addressof addressof.c	


		- Сама программа ничего не выводит, но можно сообразить, что в ней
		происходит, даже не запуская отладчик

			gdb -q ./addressof
			
			break 9 # установка break на закрывающую фигурную скобку main
					то есть в конец функции 
					
				Breakpoint 1 at 0x1164: file addressof.c, line 9

			run
			
				Breakpoint 1, main () at addressof.c:9

			
			print int_var

				$1 = 5 # число содержащееся в переменной

			print &int_var # адрес по которому находится переменая
				
				$2 = (int *) 0x7fffffffe6cc

			print int_ptr # указатель так же содержит адрес переменной
				
				$3 = (int *) 0x7fffffffe6cc

			print &int_ptr # вывести адрес указателя

				$4 = (int **) 0x7fffffffe6d0

				# 0x7fffffffe6cc + 4 = 0x7fffffffe6d0


		- Для работы с указателями есть еще один унарный оператор,
		называемый оператором разыменования (dereference). Он возвращает
		данные, находящиеся по адресу, содержащемуся в указателе, а не сам
		этот адрес. Он выглядит как звездочка перед имененем переменной,
		подобно объявлению указателя. Оператор разыменовывания тоже есть и
		в GDB с его помощью можно получить целое число, на которое
		указывает INT_PTR
			
			print *int_ptr # разыменовать адрес и вывести значение по адресу
				
				$5 = 5 
		
		- Несколько дополнив код листинга addressof2.c, продемонстрируем все
		эти понятия. В добавленных функциях printf() используется параметры
		формата, о которых я расскажу в следующем разделе. Здесь же
		ограничимся рассмотрением результата работы программы

			gcc -o addressof2 addressof2.c 
		
		- В результате компиляции и запускаполучается следующий вывод:

			int_ptr = 0x5fecaf8c
			&int_ptr = 0x5fecaf90
			*int_ptr = 0x00000005

			int_var is located at 0x5fecaf8c and contains 5
			int_ptr is located at 0x5fecaf90, contain 0x5fecaf8c,
			and points to 5 

		- Применяя унарные операторы к указателям, можно представлять себе
		что опертор адреса перемещает нас назад, а оператор разыменовывания
		вперед по направлению указателя

	
0x264 Форматные строки 	































			































































			

			















			









			














































































	












